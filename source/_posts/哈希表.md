---
title: å“ˆå¸Œè¡¨(ä½¿ç”¨C++å®ç°)
categories:
- æŠ€æœ¯ç¬”è®°
tags:
- C++
- åŠ›æ‰£åˆ·é¢˜
- Javaè½¬C++
- æ•°æ®ç»“æ„
- ç®—æ³•
---

### ğŸ˜²ç¤ºä¾‹

> ä¸»è¦ä½¿ç”¨mapå’Œset, å¦‚æœæ˜¯é”®å€¼å¯¹ç»“æ„å°±ä½¿ç”¨map, å¦‚æœä¸æ˜¯é”®å€¼å¯¹ç»“æ„ä½†æ˜¯éœ€è¦å»é‡, å°±ä½¿ç”¨set

> unordered_setæ˜¯C++æ ‡å‡†åº“ä¸­çš„ä¸€ä¸ªå®¹å™¨ï¼Œç”¨äºå­˜å‚¨å”¯ä¸€çš„å…ƒç´ é›†åˆï¼Œæ‰€ä»¥éœ€è¦å»é‡çš„æ•°æ®å¯ä»¥ç”¨å®ƒæ¥å­˜, å…ƒç´ çš„å­˜å‚¨é¡ºåºæ˜¯æ— åºçš„ã€‚ä¸‹é¢æ˜¯unordered_setçš„åŸºæœ¬ç”¨æ³•ã€å¸¸è§å‡½æ•°å’Œéå†æ–¹æ³•ï¼š


```cpp
// 1. åŒ…å«å¤´æ–‡ä»¶ï¼š
#include <unordered_set>


// 2. å£°æ˜å’Œåˆå§‹åŒ–unordered_setï¼š
std::unordered_set<int> mySet; // å£°æ˜ä¸€ä¸ªç©ºçš„unordered_set
std::unordered_set<int> mySet = {1, 2, 3}; // å£°æ˜å¹¶åˆå§‹åŒ–ä¸€ä¸ªunordered_set
std::vector<int> vec = {1, 2, 3, 4, 5};
std::unordered_set<int> mySet(vec.begin(), vec.end()); // ä½¿ç”¨è¿­ä»£å™¨èŒƒå›´æ„é€ unordered_set
std::unordered_set<int> mySet1 = {1, 2, 3};
std::unordered_set<int> mySet2(mySet1); // ä½¿ç”¨æ‹·è´æ„é€ å‡½æ•°åˆ›å»ºä¸€ä¸ªä¸å·²æœ‰unordered_setç›¸åŒçš„å‰¯æœ¬


// 3. æ’å…¥å…ƒç´ ï¼š
mySet.insert(4); // æ’å…¥å•ä¸ªå…ƒç´ 
mySet.insert({5, 6, 7}); // æ’å…¥å¤šä¸ªå…ƒç´ 


// 4. åˆ é™¤å…ƒç´ ï¼š
mySet.erase(3); // åˆ é™¤æŒ‡å®šå…ƒç´ 
mySet.clear(); // æ¸…ç©ºunordered_set


// 5. æŸ¥æ‰¾å…ƒç´ ï¼š
auto it = mySet.find(2); // æŸ¥æ‰¾æŒ‡å®šå…ƒç´ ï¼Œè¿”å›è¿­ä»£å™¨
// å¦‚æœæ²¡æœ‰æ‰¾åˆ°å°±ä¼šè¿”å›æœ€åä¸€ä¸ªçš„ä¸‹ä¸€ä¸ªæŒ‡é’ˆ
if (it != mySet.end()) {
    // æ‰¾åˆ°äº†å…ƒç´ 
} else {
    // æ²¡æœ‰æ‰¾åˆ°å…ƒç´ 
}


// 6. åˆ¤æ–­å…ƒç´ æ˜¯å¦å­˜åœ¨ï¼š
if (mySet.count(3) > 0) {
    // å…ƒç´ å­˜åœ¨
} else {
    // å…ƒç´ ä¸å­˜åœ¨
}


// 7. è·å–unordered_setçš„å¤§å°ï¼š
int size = mySet.size(); // è¿”å›unordered_setä¸­å…ƒç´ çš„ä¸ªæ•°


// 8. éå†unordered_setï¼š
for (auto it = mySet.begin(); it != mySet.end(); ++it) {
    // ä½¿ç”¨è¿­ä»£å™¨è®¿é—®unordered_setä¸­çš„å…ƒç´ 
}

// æˆ–è€…ä½¿ç”¨èŒƒå›´-based forå¾ªç¯ï¼ˆC++11åŠä»¥ä¸Šç‰ˆæœ¬ï¼‰
for (const auto& element : mySet) {
    // ä½¿ç”¨å…ƒç´ è®¿é—®unordered_setä¸­çš„å…ƒç´ 
}
```

> unordered_mapçš„ç”¨æ³•å’Œå¸¸ç”¨å‡½æ•°

```cpp
#include <iostream>
#include <unordered_map>

int main() {
    // åˆ›å»ºä¸€ä¸ªunordered_map
    std::unordered_map<int, std::string> myMap;

    // æ’å…¥é”®å€¼å¯¹
    myMap.insert({1, "apple"});
    myMap[2,"orange"];
    

    // è®¿é—®å…ƒç´ 
    std::cout << "Value at key 2: " << myMap[2] << std::endl;

    // æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨, ä½¿ç”¨count()
    if (myMap.count(2) > 0) {
        std::cout << "Key 2 exists" << std::endl;
    }

    // æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨, ä½¿ç”¨find()
    auto it = myMap.find(2);
    if (it != myMap.end()) {
        std::cout << "Key 2 found. Value: " << it->second << std::endl;
    } else {
        std::cout << "Key 2 not found." << std::endl;
    }

    // ä¿®æ”¹å…ƒç´ çš„å€¼
    myMap[1] = "grape";

    // åˆ é™¤å…ƒç´ 
    myMap.erase(2);

    // éå†unordered_map, æŒ‡é’ˆçš„firstå’Œsecondå¯ä»¥è¿”å›é”®å’Œå€¼
    for (const auto& pair : myMap) {
        std::cout << "Key: " << pair.first << ", Value: " << pair.second << std::endl;
    }

    return 0;
}
```

> æ³¨æ„ä½¿ç”¨äº†ä¸¤ç§æŸ¥æ‰¾auto, `auto it = myMap.find(2);`è¿”å›çš„æ˜¯è¿­ä»£å™¨æŒ‡é’ˆ, å¦‚æœéœ€è¦æˆå‘˜å˜é‡éœ€è¦ä½¿ç”¨`->`, è€Œ`const auto& pair : myMap`ä½¿ç”¨äº†è¿­ä»£å™¨çš„å¼•ç”¨ç±»å‹, ä½¿ç”¨æŒ‡é’ˆåˆå§‹åŒ–å¼•ç”¨ç±»å‹, å¼•ç”¨ç±»å‹çš„ä½¿ç”¨å’ŒåŸå˜é‡ä¸€æ ·, ç›´æ¥ä½¿ç”¨`.`

### ğŸ¤”ä¸€äº›ç–‘é—®è§£ç­”

#### `const auto& pair : myMap`ä¸­å¿…é¡»åŠ `const`å—?
> åœ¨éå†`unordered_map`æ—¶ï¼Œä½¿ç”¨`const auto& pair : myMap`æ˜¯ä¸€ç§å¸¸è§çš„åšæ³•ï¼Œä½†å¹¶ä¸æ˜¯å¿…é¡»çš„
> ä½¿ç”¨`const auto&`å¯ä»¥ç¡®ä¿ä½ ä¸ä¼šæ„å¤–åœ°ä¿®æ”¹`unordered_map`ä¸­çš„å…ƒç´ ã€‚è¿™æ˜¯ä¸€ç§å®‰å…¨çš„åšæ³•
> å¦‚æœéœ€è¦å†éå†çš„è¿‡ç¨‹ä¸­ä¿®æ”¹æˆ–åˆ é™¤ä¸€äº›å€¼, é‚£ä¹ˆå¯ä»¥ä½¿ç”¨`auto&`è€Œä¸æ˜¯`const auto&`

#### ä¸ºä»€ä¹ˆæœ‰çš„å“ˆå¸Œè¡¨é¢˜ç›®å¹¶æ²¡æœ‰ç”¨å“ˆå¸Œè¡¨æ¥åšè€Œæ˜¯ç”¨æ•°ç»„?
> å¦‚æœé¢˜ç›®ä¸­ç¡®å®éœ€è¦æŸ¥æ¯ä¸ªå…ƒç´ , ä½†æ˜¯å…ƒç´ çš„å–å€¼èŒƒå›´å¹¶ä¸å¤§, **è€Œä¸”ç´¢å¼•å¯ä»¥ç›´æ¥ç®—å‡ºæ¥ä¸éœ€è¦éå†**, é‚£ä¹ˆå°±å¯ä»¥ç›´æ¥ç”¨æ•°ç»„, æ¯”å¦‚[åŠ›æ‰£é¢˜ç›®242](https://leetcode.cn/problems/valid-anagram/)


### ğŸ’ªåŠ›æ‰£åˆ·é¢˜

#### 242. æœ‰æ•ˆçš„å­—æ¯å¼‚ä½è¯

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/valid-anagram/)

> è¿™ä¸ªéœ€è¦ä¸€ä¸ªå“ˆå¸Œè¡¨è®°å½•æ‰€æœ‰å­—æ¯çš„å‡ºç°æ¬¡æ•°, ä½†æ˜¯ç”±äºé¢˜ç›®ä¸­åªå‡ºç°26ä¸ªå­—æ¯, æ‰€ä»¥ä¹Ÿå¯ä»¥ç›´æ¥ä½¿ç”¨æ•°ç»„è®°å½•å­—æ¯å‡ºç°æ¬¡æ•°

> å¦‚æœsä¸­å‡ºç°å­—æ¯, åˆ™å†è®°å½•è¡¨ä¸­+1, å¦‚æœtè¡¨ä¸­å‡ºç°å­—æ¯, åˆ™å†è®°å½•è¡¨ä¸­-1, æœ€ååªéœ€è¦è®°å½•è¡¨ä¸­æœ‰æ²¡æœ‰é0å…ƒç´ 

```cpp
class Solution {
public:
    bool isAnagram(string s, string t) {
        int letter[26] = {0};
        for(int i=0; i<s.size(); i++)
            letter[s[i]-'a']++;
        for(int i=0; i<t.size(); i++)
            letter[t[i]-'a']--;
        for(int i=0; i<26; i++)
            if(letter[i]!=0)
                return false;
        return true; 
    }
};
```

#### 349. ä¸¤ä¸ªæ•°ç»„çš„äº¤é›†

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/intersection-of-two-arrays/)

```cpp
class Solution {
public:
    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {
        // æ”¶é›†nums1ä¸­å‡ºç°çš„æ‰€æœ‰æ•°å¹¶å»é‡
        unordered_set<int> data(nums1.begin(),nums1.end());
        // ç»“æœé›†åˆä¹Ÿä¸èƒ½æœ‰é‡å¤, æ‰€ä»¥å…ˆä½¿ç”¨unordered_set, éšåè½¬æ¢ä¸ºvector
        unordered_set<int> rs;
        int len = nums2.size();
        // éå†nums2, å¦‚æœæ‰¾åˆ°äº†é‡å¤å…ƒç´ , é‚£ä¹ˆåŠ å…¥ç»“æœé›†åˆ
        for(int i=0; i<len; i++){
            if(data.find(nums2[i])!=data.end())
                rs.insert(nums2[i]);
        }
        // è½¬æ¢ä¸ºvectorå¹¶è¿”å›
        return vector<int>(rs.begin(),rs.end());
    }
};
```

#### 202. å¿«ä¹æ•°

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/happy-number/)

```cpp
class Solution {
public:
    bool isHappy(int n) {
        int new_n=n, sum;           // ç”¨äºä¿å­˜æ¯ä¸€æ¬¡çš„æ•°å­—æœ¬èº«å’Œæ•°å­—å„ä½ä¸Šçš„å¹³æ–¹å’Œ
        unordered_set<int> sums;    // ç”¨äºä¿å­˜å‡ºç°è¿‡çš„æ•°å­—, é˜²æ­¢æ— é™å¾ªç¯å¯¼è‡´è¶…æ—¶
        while(new_n!=1){            // åªè¦æ²¡å‡ºç°1å°±æ¥ç€ç®—
            int k;                  // kç”¨äºå–å‡ºå„ä¸ªä½ä¸Šçš„æ•°å­—
            sum = 0;                // sumç”¨äºå­˜æ•°å­—å„ä¸ªä½ä¸Šçš„å¹³æ–¹å’Œ
            while(new_n!=0){        // æ²¡å»å®Œæ•°å­—æ‰€æœ‰ä½å°±æ¥ç€å–
                k = new_n%10;
                sum+=k*k;
                new_n/=10;
            }
            if(sums.find(sum)!=sums.end())  // å¦‚æœå‘ç°äº†é‡å¤
                return false;               // è¿”å›false
            else                            // å¦åˆ™å°±æŠŠè¿™ä¸€æ¬¡çš„æ•°å­—å­˜è¿›é›†åˆä¸­
                sums.insert(sum);
            new_n = sum;                    // è¿™ä¸€æ¬¡çš„å¹³æ–¹å’Œæ˜¯ä¸‹ä¸€æ¬¡çš„æ•°å­—
        }
        return true;                        // å¦‚æœè·³å‡ºå¾ªç¯è¯´æ˜æ‰¾åˆ°äº†1
    }
};
```

#### 1. ä¸¤æ•°ä¹‹å’Œ

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/two-sum/)

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> rs(2);              // ç”¨äºä¿å­˜ç»“æœ
        unordered_map<int,int> my_map;  // ç”¨äºä¿å­˜æ²¡ä¸€ä¸ªæ•°å­—çš„ä¸‹æ ‡
        int len = nums.size();          // å­˜ä¸€ä¸‹å¤§å°, é¿å…åå¤è®¿é—®
        for(int i=0; i<len; i++)        // å­˜å‚¨æ²¡ä¸€ä¸ªæ•°çš„ä¸‹æ ‡
            my_map[nums[i]] = i;        // æ•°å­—ä¸ºé”®, ä¸‹æ ‡ä¸ºå€¼
        for(int i=0; i<len; i++){       // æŸ¥æ‰¾æ¯ä¸€ä¸ªæ•°è¢«targetå‡å»çš„å·®åœ¨ä¸åœ¨æ•°ç»„ä¸­
            auto it = my_map.find(target-nums[i]);  // è·å–å·®çš„ä¸‹æ ‡
            if(it!=my_map.end() && it->second!=i){  // å¦‚æœå­˜åœ¨å·®, å¹¶ä¸”ä¸æ˜¯è‡ªå·±
                rs[0] = i;                          // å­˜æœ¬èº«çš„ä¸‹æ ‡
                rs[1] = it->second;                 // å­˜å·®çš„ä¸‹æ ‡
                break;                              // è·³å‡ºå¾ªç¯
            }
        }
        return rs;;                                 // è¿”å›ç»“æœ
    }
};
```

#### 454. å››æ•°ç›¸åŠ  II

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/4sum-ii/)

```cpp
// è¿˜æ²¡åš
```
