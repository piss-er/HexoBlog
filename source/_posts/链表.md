---
title: 链表(使用C++实现)
categories:
- 技术笔记
tags:
- C++
- 力扣刷题
- Java转C++
---

### 😲创建结点示例

```C++
// 单链表节点
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
int main(){
    // 使用自定义构造函数初始化, 创建指针变量并开辟实体内存空间
    ListNode* head = new ListNode(5);
    // 使用C++提供的默认构造函数, 然后通过赋值初始化
    ListNode* head = new ListNode();
    head->val = 5;

    return 0;
}
```

### 🤔一些疑问解答

#### 链表在插入删除之前必须找到需要插入删除的位置, 那么为什么时间复杂度不是O(n)而是O(1)
> 这个时间复杂度说的是找到之后的删除和插入操作, 而不包含找到这个位置所消耗的时间
> 线性表删除需要讲后面的数据往前移动一格, 插入需要后面的数据往后移动一格, 所以是O(n)
> 链表只需要将指针存储的内存位置信息改动一下即可, 没有移动操作所以是O(1)

#### C++如何手动释放内存
> Java、Python，就有自己的内存回收机制, C++最好自己手动释放内存
> `delete`释放单个指针, `delete[]`释放指针数组
```cpp
int* ptr = new int; // 动态分配一个int类型的对象
// 使用ptr
delete ptr; // 释放内存
```

如果使用`new[]`操作符动态分配了一个数组的内存，那么应该使用`delete[]`操作符来释放该内存。例如：

```cpp
int* arr = new int[5]; // 动态分配一个包含5个int类型元素的数组
// 使用arr
delete[] arr; // 释放内存
```

### 💪力扣刷题

#### 203. 移除链表元素

[力扣传送门](https://leetcode.cn/problems/remove-linked-list-elements/description/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // 创建一个虚拟头节点, 防止后面分类讨论第一个节点究竟等不等于val
        ListNode* pre = new ListNode(0);
        pre->next = head;
        // 创建一个用于遍历的指针
        ListNode* temp = pre;
        while(temp->next!=nullptr){
            // 定位到val节点的前一个, 然后删除它, 同时删除内存
            if(temp->next->val==val){
                ListNode* d = temp->next;
                temp->next = temp->next->next;
                delete d;
            }
            // 删除完成不要后移指针, 下一轮再判断一次, 如果temp->next->val!=val再考虑后移, 否则可能漏掉节点没判断
            else{
                temp = temp->next;
            }
        }
        return pre->next;
    }
};
```

#### 206. 反转链表

[力扣传送门](https://leetcode.cn/problems/reverse-linked-list/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* tmp = head;
        while(tmp!=nullptr){
            ListNode* post = tmp->next;
            tmp->next = pre;
            pre = tmp;
            tmp = post;
        }
        return pre;
    }
};
```

#### 24. 两两交换链表中的节点

[力扣传送门](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // 创建一个虚拟头指针
        ListNode* dummyhead = new ListNode(0,head);
        ListNode* tmp = dummyhead;
        ListNode* tmp2;
        ListNode* tmp3;
        while(tmp!=nullptr && tmp->next!=nullptr && tmp->next->next!=nullptr){
            // 记录两个位置
            tmp2 = tmp->next;
            tmp3 = tmp2->next->next;
            // 核心的三个操作
            tmp->next = tmp->next->next;
            tmp->next->next = tmp2;
            tmp2->next = tmp3;
            // tmp向后移动
            tmp = tmp2;
        }
        return dummyhead->next;
    }
};
```
> 指针变量本身所占的内存空间会在其作用域结束时自动释放，无需手动删除, 如`tmp`,`tmp2`,`tmp3`

> 实际上tmp不可能是空指针, 它只在后两个明确不是空指针的时候才进入循环, 每一轮循环结束的时候定位在后面第二个, 所以其实tmp不可能是空指针

> `tmp->next==nullptr`和`tmp->next->next==nullptr`的情况不用判断, 都只需要直接返回即可, 因为tmp后面只剩一个或者一个不剩都不需要操作, 直接返回即可
