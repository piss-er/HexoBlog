---
title: é“¾è¡¨(ä½¿ç”¨C++å®ç°)
categories:
- æŠ€æœ¯ç¬”è®°
tags:
- C++
- åŠ›æ‰£åˆ·é¢˜
- Javaè½¬C++
- æ•°æ®ç»“æ„
- ç®—æ³•
---

### ğŸ˜²åˆ›å»ºç»“ç‚¹ç¤ºä¾‹

```C++
// å•é“¾è¡¨èŠ‚ç‚¹
struct ListNode {
    int val;  // èŠ‚ç‚¹ä¸Šå­˜å‚¨çš„å…ƒç´ 
    ListNode *next;  // æŒ‡å‘ä¸‹ä¸€ä¸ªèŠ‚ç‚¹çš„æŒ‡é’ˆ
    ListNode(int x) : val(x), next(NULL) {}  // èŠ‚ç‚¹çš„æ„é€ å‡½æ•°
};
int main(){
    // ä½¿ç”¨è‡ªå®šä¹‰æ„é€ å‡½æ•°åˆå§‹åŒ–, åˆ›å»ºæŒ‡é’ˆå˜é‡å¹¶å¼€è¾Ÿå®ä½“å†…å­˜ç©ºé—´
    ListNode* head = new ListNode(5);
    // ä½¿ç”¨C++æä¾›çš„é»˜è®¤æ„é€ å‡½æ•°, ç„¶åé€šè¿‡èµ‹å€¼åˆå§‹åŒ–
    ListNode* head = new ListNode();
    head->val = 5;

    return 0;
}
```

### ğŸ¤”ä¸€äº›ç–‘é—®è§£ç­”

#### é“¾è¡¨åœ¨æ’å…¥åˆ é™¤ä¹‹å‰å¿…é¡»æ‰¾åˆ°éœ€è¦æ’å…¥åˆ é™¤çš„ä½ç½®, é‚£ä¹ˆä¸ºä»€ä¹ˆæ—¶é—´å¤æ‚åº¦ä¸æ˜¯O(n)è€Œæ˜¯O(1)
> è¿™ä¸ªæ—¶é—´å¤æ‚åº¦è¯´çš„æ˜¯æ‰¾åˆ°ä¹‹åçš„åˆ é™¤å’Œæ’å…¥æ“ä½œ, è€Œä¸åŒ…å«æ‰¾åˆ°è¿™ä¸ªä½ç½®æ‰€æ¶ˆè€—çš„æ—¶é—´
> çº¿æ€§è¡¨åˆ é™¤éœ€è¦è®²åé¢çš„æ•°æ®å¾€å‰ç§»åŠ¨ä¸€æ ¼, æ’å…¥éœ€è¦åé¢çš„æ•°æ®å¾€åç§»åŠ¨ä¸€æ ¼, æ‰€ä»¥æ˜¯O(n)
> é“¾è¡¨åªéœ€è¦å°†æŒ‡é’ˆå­˜å‚¨çš„å†…å­˜ä½ç½®ä¿¡æ¯æ”¹åŠ¨ä¸€ä¸‹å³å¯, æ²¡æœ‰ç§»åŠ¨æ“ä½œæ‰€ä»¥æ˜¯O(1)

#### C++å¦‚ä½•æ‰‹åŠ¨é‡Šæ”¾å†…å­˜
> Javaã€Pythonï¼Œå°±æœ‰è‡ªå·±çš„å†…å­˜å›æ”¶æœºåˆ¶, C++æœ€å¥½è‡ªå·±æ‰‹åŠ¨é‡Šæ”¾å†…å­˜
> `delete`é‡Šæ”¾å•ä¸ªæŒ‡é’ˆ, `delete[]`é‡Šæ”¾æŒ‡é’ˆæ•°ç»„
```cpp
int* ptr = new int; // åŠ¨æ€åˆ†é…ä¸€ä¸ªintç±»å‹çš„å¯¹è±¡
// ä½¿ç”¨ptr
delete ptr; // é‡Šæ”¾å†…å­˜
```

å¦‚æœä½¿ç”¨`new[]`æ“ä½œç¬¦åŠ¨æ€åˆ†é…äº†ä¸€ä¸ªæ•°ç»„çš„å†…å­˜ï¼Œé‚£ä¹ˆåº”è¯¥ä½¿ç”¨`delete[]`æ“ä½œç¬¦æ¥é‡Šæ”¾è¯¥å†…å­˜ã€‚ä¾‹å¦‚ï¼š

```cpp
int* arr = new int[5]; // åŠ¨æ€åˆ†é…ä¸€ä¸ªåŒ…å«5ä¸ªintç±»å‹å…ƒç´ çš„æ•°ç»„
// ä½¿ç”¨arr
delete[] arr; // é‡Šæ”¾å†…å­˜
```

### ğŸ’ªåŠ›æ‰£åˆ·é¢˜

#### 203. ç§»é™¤é“¾è¡¨å…ƒç´ 

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/remove-linked-list-elements/description/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        // åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿå¤´èŠ‚ç‚¹, é˜²æ­¢åé¢åˆ†ç±»è®¨è®ºç¬¬ä¸€ä¸ªèŠ‚ç‚¹ç©¶ç«Ÿç­‰ä¸ç­‰äºval
        ListNode* pre = new ListNode(0);
        pre->next = head;
        // åˆ›å»ºä¸€ä¸ªç”¨äºéå†çš„æŒ‡é’ˆ
        ListNode* temp = pre;
        while(temp->next!=nullptr){
            // å®šä½åˆ°valèŠ‚ç‚¹çš„å‰ä¸€ä¸ª, ç„¶ååˆ é™¤å®ƒ, åŒæ—¶åˆ é™¤å†…å­˜
            if(temp->next->val==val){
                ListNode* d = temp->next;
                temp->next = temp->next->next;
                delete d;
            }
            // åˆ é™¤å®Œæˆä¸è¦åç§»æŒ‡é’ˆ, ä¸‹ä¸€è½®å†åˆ¤æ–­ä¸€æ¬¡, å¦‚æœtemp->next->val!=valå†è€ƒè™‘åç§», å¦åˆ™å¯èƒ½æ¼æ‰èŠ‚ç‚¹æ²¡åˆ¤æ–­
            else{
                temp = temp->next;
            }
        }
        return pre->next;
    }
};
```

#### 206. åè½¬é“¾è¡¨

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/reverse-linked-list/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        ListNode* tmp = head;
        while(tmp!=nullptr){
            ListNode* post = tmp->next;
            tmp->next = pre;
            pre = tmp;
            tmp = post;
        }
        return pre;
    }
};
```

#### 24. ä¸¤ä¸¤äº¤æ¢é“¾è¡¨ä¸­çš„èŠ‚ç‚¹

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        // åˆ›å»ºä¸€ä¸ªè™šæ‹Ÿå¤´æŒ‡é’ˆ
        ListNode* dummyhead = new ListNode(0,head);
        ListNode* tmp = dummyhead;
        ListNode* tmp2;
        ListNode* tmp3;
        while(tmp!=nullptr && tmp->next!=nullptr && tmp->next->next!=nullptr){
            // è®°å½•ä¸¤ä¸ªä½ç½®
            tmp2 = tmp->next;
            tmp3 = tmp2->next->next;
            // æ ¸å¿ƒçš„ä¸‰ä¸ªæ“ä½œ
            tmp->next = tmp->next->next;
            tmp->next->next = tmp2;
            tmp2->next = tmp3;
            // tmpå‘åç§»åŠ¨
            tmp = tmp2;
        }
        return dummyhead->next;
    }
};
```
> æŒ‡é’ˆå˜é‡æœ¬èº«æ‰€å çš„å†…å­˜ç©ºé—´ä¼šåœ¨å…¶ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨é‡Šæ”¾ï¼Œæ— éœ€æ‰‹åŠ¨åˆ é™¤, å¦‚`tmp`,`tmp2`,`tmp3`

> å®é™…ä¸Štmpä¸å¯èƒ½æ˜¯ç©ºæŒ‡é’ˆ, å®ƒåªåœ¨åä¸¤ä¸ªæ˜ç¡®ä¸æ˜¯ç©ºæŒ‡é’ˆçš„æ—¶å€™æ‰è¿›å…¥å¾ªç¯, æ¯ä¸€è½®å¾ªç¯ç»“æŸçš„æ—¶å€™å®šä½åœ¨åé¢ç¬¬äºŒä¸ª, æ‰€ä»¥å…¶å®tmpä¸å¯èƒ½æ˜¯ç©ºæŒ‡é’ˆ

> `tmp->next==nullptr`å’Œ`tmp->next->next==nullptr`çš„æƒ…å†µä¸ç”¨åˆ¤æ–­, éƒ½åªéœ€è¦ç›´æ¥è¿”å›å³å¯, å› ä¸ºtmpåé¢åªå‰©ä¸€ä¸ªæˆ–è€…ä¸€ä¸ªä¸å‰©éƒ½ä¸éœ€è¦æ“ä½œ, ç›´æ¥è¿”å›å³å¯

#### 19. åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬ N ä¸ªç»“ç‚¹

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        // è™šæ‹Ÿå¤´èŠ‚ç‚¹, é¿å…åˆ†ç±»è®¨è®º
        ListNode* dummyhead = new ListNode(0,head);
        // åŒæŒ‡é’ˆ
        ListNode* tmp1 = dummyhead;
        ListNode* tmp2 = tmp1;
        // è®©ä¸¤ä¸ªæŒ‡é’ˆä¸­é—´é—´éš™å¤§å°ä¸ºn
        while(n-->0){
            tmp2 = tmp2->next;
        }
        // åŒæ—¶å‘åç§»åŠ¨, çŸ¥é“åä¸€ä¸ªæŒ‡é’ˆç§»åŠ¨åˆ°æœ€åä¸€ä¸ª
        while(tmp2->next!=nullptr){
            tmp1 = tmp1->next;
            tmp2 = tmp2->next;
        }
        // å‰ä¸€ä¸ªæŒ‡é’ˆçš„ä½ç½®è¿›è¡Œåˆ é™¤æ“ä½œ
        ListNode* d = tmp1->next;
        tmp1->next = tmp1->next->next;
        delete d;
        return dummyhead->next;
    }
};
```

#### é¢è¯•é¢˜ 02.07. é“¾è¡¨ç›¸äº¤

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        // å®šä¹‰ä¸¤ä¸ªæŒ‡é’ˆç”¨äºæŒ‡å‘é•¿é“¾è¡¨å’ŒçŸ­é“¾è¡¨, æš‚ä¸”è®¤ä¸ºAé•¿BçŸ­, ç»Ÿè®¡å®Œé•¿åº¦å¦‚è‹¥ä¸å¯¹å†äº¤æ¢åœ°å€
        ListNode* longOne = headA;
        ListNode* shortOne = headB;
        // ç»Ÿè®¡ä¸¤ä¸ªé“¾è¡¨é•¿åº¦
        int longLen=0, shortLen=0;
        ListNode* tmp = headA;
        while(tmp!=NULL){
            longLen++;
            tmp = tmp->next;
        }
        tmp = headB;
        while(tmp!=NULL){
            shortLen++;
            tmp = tmp->next;
        }
        // å¦‚æœAçŸ­Bé•¿å°±äº¤æ¢æŒ‡é’ˆ
        if(longLen<shortLen){
            swap(longLen,shortLen);
            swap(longOne,shortOne);
        }
        // è®©é•¿é“¾è¡¨ä¸Šçš„æŒ‡é’ˆå¾€åç§»åŠ¨, è®©ä¸¤ä¸ªé“¾è¡¨æŒ‡é’ˆä½äºåŒä¸€èµ·ç‚¹
        int move = longLen-shortLen;
        while(move-->0)
            longOne = longOne->next;
        // å®šä¹‰è¿”å›å€¼, å¦‚æœæ²¡æ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„èŠ‚ç‚¹å°±è¿”å›NULL
        ListNode* rs = NULL;
        // ä¸¤ä¸ªæŒ‡é’ˆåŒæ­¥å‘åç§»åŠ¨, å¦‚æœæ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„èŠ‚ç‚¹å°±break
        while(longOne!=NULL){
            if(longOne==shortOne){
                rs = longOne;
                break;
            }
            longOne = longOne->next;
            shortOne = shortOne->next;
        }
        return rs;
    }
};
```

#### 142. ç¯å½¢é“¾è¡¨ II

[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/linked-list-cycle-ii/)

> ç»Ÿè®¡é“¾è¡¨å¤§å°è‚¯å®šæ˜¯ä¸è¡Œçš„, æ°¸è¿œèµ°ä¸åˆ°å¤´
> å¦‚æœæƒ³å­˜ä¸‹æ¥æ‰€æœ‰èŠ‚ç‚¹çš„åœ°å€, ç„¶åçœ‹çœ‹ä»€ä¹ˆæ—¶å€™å­˜åˆ°ä¸€ä¸ªé‡å¤çš„åœ°å€, è¿™ç§æ–¹æ³•å›ºç„¶é€»è¾‘ä¸Šè®²çš„é€š, ä½†æ˜¯å®é™…ä¸šåŠ¡ä¸­çš„èŠ‚ç‚¹éå¸¸å¤š, é‚£ä¹ˆè¿™ç§æ–¹æ³•å¿…ç„¶ååˆ†å ç”¨ç©ºé—´, ä¹Ÿä¸è¡Œ
> å¯ä»¥ç”¨å¿«æ…¢æŒ‡é’ˆ, å¿«æŒ‡é’ˆä¸€æ¬¡èµ°ä¸¤æ ¼, æ…¢æŒ‡é’ˆä¸€æ¬¡èµ°ä¸€æ ¼, è¿™æ ·çš„è¯, åªè¦æœ‰åœˆ, é‚£ä¹ˆå¿«æŒ‡é’ˆä¸€å®šèƒ½ä»åé¢å†ç»•ä¸€åœˆè¿½ä¸Šæ…¢æŒ‡é’ˆ

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png)

> å‡è®¾ä»å¤´ç»“ç‚¹åˆ°ç¯å½¢å…¥å£èŠ‚ç‚¹ çš„èŠ‚ç‚¹æ•°ä¸ºx, ç¯å½¢å…¥å£èŠ‚ç‚¹åˆ° `fast`æŒ‡é’ˆä¸`slow`æŒ‡é’ˆç›¸é‡èŠ‚ç‚¹ èŠ‚ç‚¹æ•°ä¸ºy, ä»ç›¸é‡èŠ‚ç‚¹ å†åˆ°ç¯å½¢å…¥å£èŠ‚ç‚¹èŠ‚ç‚¹æ•°ä¸º z

> é‚£ä¹ˆç›¸é‡æ—¶ï¼š `slow`æŒ‡é’ˆèµ°è¿‡çš„èŠ‚ç‚¹æ•°ä¸º: `x + y`ï¼Œ `fast`æŒ‡é’ˆèµ°è¿‡çš„èŠ‚ç‚¹æ•°ï¼š`x + y + n (y + z)`ï¼Œnä¸º`fast`æŒ‡é’ˆåœ¨ç¯å†…èµ°äº†nåœˆæ‰é‡åˆ°`slow`æŒ‡é’ˆï¼Œ `(y+z)`ä¸º ä¸€åœˆå†…èŠ‚ç‚¹çš„ä¸ªæ•°Aã€‚

> å› ä¸º`fast`æŒ‡é’ˆæ˜¯ä¸€æ­¥èµ°ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œ`slow`æŒ‡é’ˆä¸€æ­¥èµ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ æ‰€ä»¥ `fastæŒ‡é’ˆèµ°è¿‡çš„èŠ‚ç‚¹æ•° = slowæŒ‡é’ˆèµ°è¿‡çš„èŠ‚ç‚¹æ•° * 2`ï¼š

> `(x + y) * 2 = x + y + n (y + z)`

> ä¸¤è¾¹æ¶ˆæ‰ä¸€ä¸ª`(x+y): x + y = n (y + z)`

> å› ä¸ºè¦æ‰¾ç¯å½¢çš„å…¥å£ï¼Œé‚£ä¹ˆè¦æ±‚çš„æ˜¯xï¼Œå› ä¸ºxè¡¨ç¤º å¤´ç»“ç‚¹åˆ° ç¯å½¢å…¥å£èŠ‚ç‚¹çš„çš„è·ç¦»ã€‚

> æ‰€ä»¥è¦æ±‚x ï¼Œå°†xå•ç‹¬æ”¾åœ¨å·¦é¢ï¼š`x = n (y + z) - y` ,

> å†ä»`n(y+z)`ä¸­æå‡ºä¸€ä¸ª `(y+z)`æ¥ï¼Œæ•´ç†å…¬å¼ä¹‹åä¸ºå¦‚ä¸‹å…¬å¼ï¼š`x = (n - 1) (y + z) + z` æ³¨æ„è¿™é‡Œnä¸€å®šæ˜¯å¤§äºç­‰äº1çš„ï¼Œå› ä¸º `fast`æŒ‡é’ˆè‡³å°‘è¦å¤šèµ°ä¸€åœˆæ‰èƒ½ç›¸é‡`slow`æŒ‡é’ˆ

> è¿™ä¸ªå…¬å¼è¯´æ˜ä»€ä¹ˆå‘¢ï¼Ÿ

> å…ˆæ‹¿nä¸º1çš„æƒ…å†µæ¥ä¸¾ä¾‹ï¼Œæ„å‘³ç€`fast`æŒ‡é’ˆåœ¨ç¯å½¢é‡Œè½¬äº†ä¸€åœˆä¹‹åï¼Œå°±é‡åˆ°äº† `slow`æŒ‡é’ˆäº†

> å½“ nä¸º1çš„æ—¶å€™ï¼Œå…¬å¼å°±åŒ–è§£ä¸º `x = z`ï¼Œ

> è¿™å°±æ„å‘³ç€ï¼Œ**ä»å¤´ç»“ç‚¹å‡ºå‘**ä¸€ä¸ªæŒ‡é’ˆï¼Œ**ä»ç›¸é‡èŠ‚ç‚¹ä¹Ÿå‡ºå‘**ä¸€ä¸ªæŒ‡é’ˆï¼Œè¿™ä¸¤ä¸ªæŒ‡é’ˆæ¯æ¬¡åªèµ°ä¸€ä¸ªèŠ‚ç‚¹ï¼Œ é‚£ä¹ˆå½“è¿™ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡çš„æ—¶å€™å°±æ˜¯ ç¯å½¢å…¥å£çš„èŠ‚ç‚¹

> å¦‚æœnä¸ç­‰äº1, æƒ…å†µä¹Ÿä¸€æ ·, ä»ç„¶ä¼šç›¸é‡, åªä¸è¿‡ä»ç›¸é‡èŠ‚ç‚¹å‡ºå‘çš„æŒ‡é’ˆéœ€è¦èµ°å‡ åœˆæ‰èƒ½ç¢°ä¸Šå¦ä¸€ä¸ªæŒ‡é’ˆ

![](https://code-thinking.cdn.bcebos.com/gifs/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif)

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast!=NULL && fast->next!=NULL){
            slow = slow->next;
            fast = fast->next->next;
            if(fast==slow)
                break;
        }
        if(fast==NULL || fast->next==NULL)
            return NULL;
        ListNode* find = head;
        while(fast!=find){
            fast = fast->next;
            find = find->next;
        }
        return find;
    }
};
```