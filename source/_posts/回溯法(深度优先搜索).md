title: å›æº¯æ³•-æ·±åº¦ä¼˜å…ˆæœç´¢(ä½¿ç”¨C++å®ç°)
categories:
- æŠ€æœ¯ç¬”è®°
tags:
- C++
- åŠ›æ‰£åˆ·é¢˜
- Javaè½¬C++
- æ•°æ®ç»“æ„
- ç®—æ³•
---
### ğŸ˜²ç¤ºä¾‹

> å›æº¯çš„æœ¬è´¨æ˜¯ç©·ä¸¾, å³æŒ‰ç…§ä¸€å®šçš„é¡ºåºå¯¹å…ƒç´ è¿›è¡Œæ’åˆ—ç»„åˆæ‰¾åˆ°æ‰€æœ‰å¯èƒ½æƒ…å†µ, éšåç­›é€‰å‡ºéœ€è¦çš„ä¸€ä¸ªæœ€ä¼˜æƒ…å†µæˆ–è€…ç¬¦åˆè¦æ±‚çš„å¤šä¸ªæƒ…å†µ

> å¦‚æœä¸€ä¸ªé—®é¢˜å¯ä»¥æŠ½è±¡æˆæ•°å­¦ä¸­çš„æ’åˆ—ç»„åˆ, é‚£ä¹ˆä¹Ÿå¯ä»¥ä½¿ç”¨å›æº¯æ³•æ¥æ‰¾åˆ°æ‰€æœ‰çš„æ’åˆ—ç»„åˆ, å…¶ä¸­, æ’åˆ—ä¸ç”¨å»é‡, ç»„åˆéœ€è¦å»é‡

> å›æº¯æ³•ä½¿ç”¨çš„æœç´¢æ–¹å¼å¯ä»¥çœ‹ä½œæ·±åº¦ä¼˜å…ˆæœç´¢, å³æŒ‰ä¸€ç§æ–¹å¼æœç´¢åˆ°å°½å¤´ä¹‹åå†å›é€€

> ä¸‹é¢å±•ç¤ºä¸€ç§å›æº¯æ³•çš„ç»å…¸å†™æ³•

```cpp
vector<vector<int>> result;     // ç»“æœ
vector<int> path;               // è·¯å¾„
void dfs(......){               // æ·±åº¦ä¼˜å…ˆæœç´¢
    if(......){                 // ç»ˆç‚¹æ¡ä»¶
        result.push_back(path); // æ·»åŠ è¿™ä¸€æ¬¡çš„è·¯å¾„
        return;                 // å‘ä¸Šå›æº¯
    }
    for(int i=start; i<=n; i++){// å‘ä¸‹æŒ¨ä¸ªæœç´¢
        path.push_back(i);      // æ·»åŠ ä¸€ä¸ªèŠ‚ç‚¹
        dfs(n,k,i+1);           // å‘ä¸‹æœç´¢
        path.pop_back();        // å›æº¯
    }
}

vector<vector<int>> ......(......){
    dfs(......);
    return result;
}
```
### ğŸ¤”ä¸€äº›ç–‘é—®è§£ç­”

#### å¦‚ä½•å¯¹ç»“æœè¿›è¡Œå»é‡
> å¦‚æœå…è®¸å¯¹é¢˜å¹²æä¾›çš„æ•°ç»„è¿›è¡Œæ‰“ä¹±, é‚£ä¹ˆå¯ä»¥å…ˆæ’åºå†ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ ‡è®°æ˜¯å¦åˆ°è¾¾è¿‡è¯¥ä½ç½®, ä»è€Œè¿›è¡Œå»é‡, ä¾‹å¦‚[å­é›†II](#90-å­é›†-ii)
> ä¸è®ºæ˜¯å¦å¯ä»¥æ‰“ä¹±æ•°ç»„éƒ½å¯ä»¥ä½¿ç”¨setæ–¹æ³•è¿›è¡Œå»é‡, å› ä¸ºsetæä¾›äº†find()æ–¹æ³•è¿›è¡ŒO(1)å¤æ‚åº¦çš„æŸ¥æ‰¾, ä¾‹å¦‚[é€’å¢å­åºåˆ—](#491-é€’å¢å­åºåˆ—)

#### æœ‰æ²¡æœ‰ä»€ä¹ˆæ–¹æ³•èƒ½å¤ŸæŠŠé€’å½’å†™æ³•å†™æˆéé€’å½’å†™æ³•?
> 
### ğŸ’ªåŠ›æ‰£åˆ·é¢˜

#### 77. ç»„åˆ
[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/combinations/)
```cpp
class Solution {
    vector<vector<int>> result;     // ç»“æœ
    vector<int> path;               // è·¯å¾„
private:
    void dfs(int n, int k, int start){  // æ·±åº¦ä¼˜å…ˆæœç´¢
        if(path.size()==k){             // ç»ˆç‚¹æ¡ä»¶
        result.push_back(path);         // æ·»åŠ è¿™ä¸€æ¬¡çš„è·¯å¾„
        return;                         // å‘ä¸Šå›æº¯
        for(int i=start; i<=n; i++){    // å‘ä¸‹æŒ¨ä¸ªæœç´¢
            path.push_back(i);          // æ·»åŠ ä¸€ä¸ªèŠ‚ç‚¹
            dfs(n,k,i+1);               // å‘ä¸‹æœç´¢
            path.pop_back();            // å›æº¯
        }
    }
public:
    vector<vector<int>> combine(int n, int k) {
        dfs(n,k,1);
        return result;
    }
};
```

#### 17. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ
[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

```cpp
class Solution {
private:
    const string letters_map[10] = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz"
    };
    vector<string> result;
    string s;
public:
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0)
            return result;
        dfs(digits,0);
        return result;
    }
    void dfs(string& digits, int index){
        if(index==digits.size()){
            result.push_back(s);
            return;
        }
        string temp = letters_map[digits[index]-'0'];
        int len = temp.size();
        for(int i=0; i<len; i++){
            s.push_back(temp[i]);
            dfs(digits,index+1);
            s.pop_back();
        }
    }
};
```

#### 39. ç»„åˆæ€»å’Œ
[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/combination-sum/)
```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> temp;
    void dfs(vector<int>& candidates, int target, int sum, int start){
        if(target==sum){
            result.push_back(temp);
            return;
        }
        if(sum>target){
            return;
        }
        int len = candidates.size();
        for(int i=start; i<len && sum+candidates[i]<=target; i++){
            temp.push_back(candidates[i]);
            dfs(candidates,target,sum+candidates[i],i);
            temp.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        dfs(candidates, target, 0, 0);
        return result;
    }
};
```

#### 131. åˆ†å‰²å›æ–‡ä¸²
[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/palindrome-partitioning/)
```cpp
class Solution {
private:
    vector<vector<string>> result;
    vector<string> temp;
    bool judge(string& s, int start, int end){
        while(start<end){
            if(s[start]!=s[end])
                return false;
            start++;
            end--;
        }
        return true;
    }
    void dfs(string& s, int start){
        int len = s.size();
        if(start==len){
            result.push_back(temp);
            return;
        }
        for(int i=start; i<len; i++){
            if(judge(s, start, i)){
                string str = s.substr(start,i-start+1);
                temp.push_back(str);
                dfs(s,i+1);
                temp.pop_back();
            }
        }
    }
public:
    vector<vector<string>> partition(string s) {
        dfs(s,0);
        return result;
    }
};
```

#### 78. å­é›†
[åŠ›æ‰£ä¼ é€é—¨](https://leetcode.cn/problems/subsets/)
```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> temp;
    void dfs(vector<int>& nums, int start){
        int len = nums.size();
        if(start==len)
            return;
        for(int i=start; i<len; i++){
            temp.push_back(nums[i]);
            result.push_back(temp);
            dfs(nums,i+1);
            temp.pop_back();
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        result.push_back(temp);
        dfs(nums,0);
        return result;
    }
};
```

#### 90. å­é›† II
[ä¼ é€é—¨](https://leetcode.cn/problems/subsets-ii/description/)

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void dfs(vector<int>& nums, vector<bool> arrived, int start){
        result.push_back(path);         // æ¯æ¬¡è·¯å¾„å¢åŠ éƒ½éœ€è¦è®°å½•ä¸ºä¸€ç§ç»“æœ
        for(int i=start; i<nums.size(); i++){
            if(i>0 && nums[i]==nums[i-1] && !arrived[i-1])  // å»é‡, å¦‚æœåŒä¸€å±‚æœ‰ç›¸åŒçš„æ•°å–è¿‡, é‚£ä¹ˆè¿™ä¸€æ¬¡ä¸å†å–ç›¸åŒçš„æ•°
                continue;
            arrived[i] = true;      // å¢åŠ è·¯å¾„å…ƒç´ 
            path.push_back(nums[i]);
            dfs(nums,arrived,i+1);
            path.pop_back();
            arrived[i] = false;
        }
    }
public:
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool> arrived(nums.size(),false);    // è®°å½•æ˜¯å¦åˆ°è¾¾
        sort(nums.begin(),nums.end());              // æ’åº
        dfs(nums,arrived,0);                        // æœç´¢
        return result;
    }
};
```

#### 40. ç»„åˆæ€»å’Œ II

[ä¼ é€é—¨](https://leetcode.cn/problems/combination-sum-ii/description/)

> æœ¬è§£æ³•æ•ˆç‡è¾ƒä½

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void dfs(vector<int>& candidates,vector<bool> arrived, int sum, int target, int start){
        if(sum==target){
            result.push_back(path);
            return;
        }
        if(sum>target)
            return;
        for(int i=start; i<candidates.size(); i++){
            if(i>0 && candidates[i]==candidates[i-1] && !arrived[i-1])
                continue;
            arrived[i] = true;
            path.push_back(candidates[i]);
            dfs(candidates,arrived,sum+candidates[i],target,i+1);
            path.pop_back();
            arrived[i] = false;
        }
    }
public:
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        sort(candidates.begin(),candidates.end());
        vector<bool> arrived(candidates.size(),false);
        dfs(candidates,arrived,0,target,0);
        return result;
    }
};
```

#### 491. é€’å¢å­åºåˆ—

[ä¼ é€é—¨](https://leetcode.cn/problems/non-decreasing-subsequences/description/)

> **æ–¹æ³•ä¸€** æ‰¾åˆ°ç¬¦åˆè¦æ±‚èƒ½åŠ å…¥è·¯å¾„ä¸­çš„æ•°, ç„¶ååŠ å…¥è·¯å¾„

```cpp
for(int i=start; i<nums.size(); i++){
    if((path.empty() || path.back()<=nums[i]) && uset.find(nums[i])==uset.end()){
        uset.insert(nums[i]);
        path.push_back(nums[i]);
        dfs(nums,i+1);
        path.pop_back();
    }
}
```

> **æ–¹æ³•äºŒ** æˆ–è€…æ˜¯æ‰¾åˆ°ä¸ç¬¦åˆè¦æ±‚ä¸èƒ½åŠ å…¥è·¯å¾„ä¸­çš„æ•°, è·³è¿‡

```cpp
for (int i = start; i<nums.size(); i++) {
    if ((!path.empty() && nums[i] < path.back()) || uset.find(nums[i]) != uset.end())
        continue;
    uset.insert(nums[i]); 
    path.push_back(nums[i]);
    backtracking(nums, i + 1);
    path.pop_back();
}
```

> æ•´ä½“ä»£ç å¦‚ä¸‹

```cpp
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void dfs(vector<int>& nums, int start){
        if(path.size()>=2)          // é•¿åº¦å¤§äº2çš„åºåˆ—
            result.push_back(path); // è®°å½•
        if(start==nums.size())      // å¦‚æœå¯»æ‰¾çš„ç´¢å¼•å€¼è¶…è¿‡æ•°ç»„
            return;                 // é€€å‡º
        unordered_set<int> uset;    // åˆ›å»ºsetç”¨äºåœ¨æœ¬å±‚ä¸­å»é‡
        for(int i=start; i<nums.size(); i++){
            if((path.empty() || path.back()<=nums[i]) && uset.find(nums[i])==uset.end()){       // æ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„nums[i]
                uset.insert(nums[i]);       // åŠ å…¥set 
                path.push_back(nums[i]);
                dfs(nums,i+1);
                path.pop_back();
            }
        }
    }
public:
    vector<vector<int>> findSubsequences(vector<int>& nums) {
        dfs(nums,0);
        return result;
    }
};
```