<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>回溯法-深度优先搜索(使用C++实现)</title>
    <link href="/2023/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95(%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)/"/>
    <url>/2023/09/13/%E5%9B%9E%E6%BA%AF%E6%B3%95(%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)/</url>
    
    <content type="html"><![CDATA[<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 😲示例</h3><blockquote><p>回溯的本质是穷举, 即按照一定的顺序对元素进行排列组合找到所有可能情况, 随后筛选出需要的一个最优情况或者符合要求的多个情况</p></blockquote><blockquote><p>如果一个问题可以抽象成数学中的排列组合, 那么也可以使用回溯法来找到所有的排列组合, 其中, 排列不用去重, 组合需要去重</p></blockquote><blockquote><p>回溯法使用的搜索方式可以看作深度优先搜索, 即按一种方式搜索到尽头之后再回退</p></blockquote><blockquote><p>下面展示一种回溯法的经典写法</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp">vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;     <span class="hljs-comment">// 结果</span><br>vector&lt;<span class="hljs-type">int</span>&gt; path;               <span class="hljs-comment">// 路径</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(......)</span></span>&#123;               <span class="hljs-comment">// 深度优先搜索</span><br>    <span class="hljs-keyword">if</span>(......)&#123;                 <span class="hljs-comment">// 终点条件</span><br>        result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 添加这一次的路径</span><br>        <span class="hljs-keyword">return</span>;                 <span class="hljs-comment">// 向上回溯</span><br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;=n; i++)&#123;<span class="hljs-comment">// 向下挨个搜索</span><br>        path.<span class="hljs-built_in">push_back</span>(i);      <span class="hljs-comment">// 添加一个节点</span><br>        <span class="hljs-built_in">dfs</span>(n,k,i+<span class="hljs-number">1</span>);           <span class="hljs-comment">// 向下搜索</span><br>        path.<span class="hljs-built_in">pop_back</span>();        <span class="hljs-comment">// 回溯</span><br>    &#125;<br>&#125;<br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; ......(......)&#123;<br>    <span class="hljs-built_in">dfs</span>(......);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些疑问解答"><a class="markdownIt-Anchor" href="#一些疑问解答"></a> 🤔一些疑问解答</h3><h4 id="如何对结果进行去重"><a class="markdownIt-Anchor" href="#如何对结果进行去重"></a> 如何对结果进行去重</h4><blockquote><p>如果允许对题干提供的数组进行打乱, 那么可以先排序再使用一个数组标记是否到达过该位置, 从而进行去重, 例如<a href="#90-%E5%AD%90%E9%9B%86-ii">子集II</a><br />不论是否可以打乱数组都可以使用set方法进行去重, 因为set提供了find()方法进行O(1)复杂度的查找, 例如<a href="#491-%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97">递增子序列</a></p></blockquote><h4 id="有没有什么方法能够把递归写法写成非递归写法"><a class="markdownIt-Anchor" href="#有没有什么方法能够把递归写法写成非递归写法"></a> 有没有什么方法能够把递归写法写成非递归写法?</h4><blockquote></blockquote><h3 id="力扣刷题"><a class="markdownIt-Anchor" href="#力扣刷题"></a> 💪力扣刷题</h3><h4 id="77-组合"><a class="markdownIt-Anchor" href="#77-组合"></a> 77. 组合</h4><p><a href="https://leetcode.cn/problems/combinations/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;     <span class="hljs-comment">// 结果</span><br>    vector&lt;<span class="hljs-type">int</span>&gt; path;               <span class="hljs-comment">// 路径</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> start)</span></span>&#123;  <span class="hljs-comment">// 深度优先搜索</span><br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()==k)&#123;             <span class="hljs-comment">// 终点条件</span><br>        result.<span class="hljs-built_in">push_back</span>(path);         <span class="hljs-comment">// 添加这一次的路径</span><br>        <span class="hljs-keyword">return</span>;                         <span class="hljs-comment">// 向上回溯</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;=n; i++)&#123;    <span class="hljs-comment">// 向下挨个搜索</span><br>            path.<span class="hljs-built_in">push_back</span>(i);          <span class="hljs-comment">// 添加一个节点</span><br>            <span class="hljs-built_in">dfs</span>(n,k,i+<span class="hljs-number">1</span>);               <span class="hljs-comment">// 向下搜索</span><br>            path.<span class="hljs-built_in">pop_back</span>();            <span class="hljs-comment">// 回溯</span><br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combine</span>(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-built_in">dfs</span>(n,k,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="17-电话号码的字母组合"><a class="markdownIt-Anchor" href="#17-电话号码的字母组合"></a> 17. 电话号码的字母组合</h4><p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">const</span> string letters_map[<span class="hljs-number">10</span>] = &#123;<br>        <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;abc&quot;</span>,<br>        <span class="hljs-string">&quot;def&quot;</span>,<br>        <span class="hljs-string">&quot;ghi&quot;</span>,<br>        <span class="hljs-string">&quot;jkl&quot;</span>,<br>        <span class="hljs-string">&quot;mno&quot;</span>,<br>        <span class="hljs-string">&quot;pqrs&quot;</span>,<br>        <span class="hljs-string">&quot;tuv&quot;</span>,<br>        <span class="hljs-string">&quot;wxyz&quot;</span><br>    &#125;;<br>    vector&lt;string&gt; result;<br>    string s;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">letterCombinations</span><span class="hljs-params">(string digits)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(digits.<span class="hljs-built_in">size</span>()==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> result;<br>        <span class="hljs-built_in">dfs</span>(digits,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; digits, <span class="hljs-type">int</span> index)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(index==digits.<span class="hljs-built_in">size</span>())&#123;<br>            result.<span class="hljs-built_in">push_back</span>(s);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        string temp = letters_map[digits[index]-<span class="hljs-string">&#x27;0&#x27;</span>];<br>        <span class="hljs-type">int</span> len = temp.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>            s.<span class="hljs-built_in">push_back</span>(temp[i]);<br>            <span class="hljs-built_in">dfs</span>(digits,index+<span class="hljs-number">1</span>);<br>            s.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="39-组合总和"><a class="markdownIt-Anchor" href="#39-组合总和"></a> 39. 组合总和</h4><p><a href="https://leetcode.cn/problems/combination-sum/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(target==sum)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;target)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> len = candidates.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;len &amp;&amp; sum+candidates[i]&lt;=target; i++)&#123;<br>            temp.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">dfs</span>(candidates,target,sum+candidates[i],i);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-built_in">dfs</span>(candidates, target, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="131-分割回文串"><a class="markdownIt-Anchor" href="#131-分割回文串"></a> 131. 分割回文串</h4><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;string&gt;&gt; result;<br>    vector&lt;string&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(start&lt;end)&#123;<br>            <span class="hljs-keyword">if</span>(s[start]!=s[end])<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            start++;<br>            end--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(start==len)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">judge</span>(s, start, i))&#123;<br>                string str = s.<span class="hljs-built_in">substr</span>(start,i-start+<span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">push_back</span>(str);<br>                <span class="hljs-built_in">dfs</span>(s,i+<span class="hljs-number">1</span>);<br>                temp.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;string&gt;&gt; <span class="hljs-built_in">partition</span>(string s) &#123;<br>        <span class="hljs-built_in">dfs</span>(s,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="78-子集"><a class="markdownIt-Anchor" href="#78-子集"></a> 78. 子集</h4><p><a href="https://leetcode.cn/problems/subsets/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; temp;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(start==len)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;len; i++)&#123;<br>            temp.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            result.<span class="hljs-built_in">push_back</span>(temp);<br>            <span class="hljs-built_in">dfs</span>(nums,i+<span class="hljs-number">1</span>);<br>            temp.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsets</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        result.<span class="hljs-built_in">push_back</span>(temp);<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="90-子集-ii"><a class="markdownIt-Anchor" href="#90-子集-ii"></a> 90. 子集 II</h4><p><a href="https://leetcode.cn/problems/subsets-ii/description/">传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, vector&lt;<span class="hljs-type">bool</span>&gt; arrived, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        result.<span class="hljs-built_in">push_back</span>(path);         <span class="hljs-comment">// 每次路径增加都需要记录为一种结果</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]==nums[i<span class="hljs-number">-1</span>] &amp;&amp; !arrived[i<span class="hljs-number">-1</span>])  <span class="hljs-comment">// 去重, 如果同一层有相同的数取过, 那么这一次不再取相同的数</span><br>                <span class="hljs-keyword">continue</span>;<br>            arrived[i] = <span class="hljs-literal">true</span>;      <span class="hljs-comment">// 增加路径元素</span><br>            path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>            <span class="hljs-built_in">dfs</span>(nums,arrived,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            arrived[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">subsetsWithDup</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">arrived</span><span class="hljs-params">(nums.size(),<span class="hljs-literal">false</span>)</span></span>;    <span class="hljs-comment">// 记录是否到达</span><br>        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());              <span class="hljs-comment">// 排序</span><br>        <span class="hljs-built_in">dfs</span>(nums,arrived,<span class="hljs-number">0</span>);                        <span class="hljs-comment">// 搜索</span><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="40-组合总和-ii"><a class="markdownIt-Anchor" href="#40-组合总和-ii"></a> 40. 组合总和 II</h4><p><a href="https://leetcode.cn/problems/combination-sum-ii/description/">传送门</a></p><blockquote><p>本解法效率较低</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates,vector&lt;<span class="hljs-type">bool</span>&gt; arrived, <span class="hljs-type">int</span> sum, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(sum==target)&#123;<br>            result.<span class="hljs-built_in">push_back</span>(path);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(sum&gt;target)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;candidates.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; candidates[i]==candidates[i<span class="hljs-number">-1</span>] &amp;&amp; !arrived[i<span class="hljs-number">-1</span>])<br>                <span class="hljs-keyword">continue</span>;<br>            arrived[i] = <span class="hljs-literal">true</span>;<br>            path.<span class="hljs-built_in">push_back</span>(candidates[i]);<br>            <span class="hljs-built_in">dfs</span>(candidates,arrived,sum+candidates[i],target,i+<span class="hljs-number">1</span>);<br>            path.<span class="hljs-built_in">pop_back</span>();<br>            arrived[i] = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">combinationSum2</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; candidates, <span class="hljs-type">int</span> target) &#123;<br>        <span class="hljs-built_in">sort</span>(candidates.<span class="hljs-built_in">begin</span>(),candidates.<span class="hljs-built_in">end</span>());<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">arrived</span><span class="hljs-params">(candidates.size(),<span class="hljs-literal">false</span>)</span></span>;<br>        <span class="hljs-built_in">dfs</span>(candidates,arrived,<span class="hljs-number">0</span>,target,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="491-递增子序列"><a class="markdownIt-Anchor" href="#491-递增子序列"></a> 491. 递增子序列</h4><p><a href="https://leetcode.cn/problems/non-decreasing-subsequences/description/">传送门</a></p><blockquote><p><strong>方法一</strong> 找到符合要求能加入路径中的数, 然后加入路径</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>    <span class="hljs-keyword">if</span>((path.<span class="hljs-built_in">empty</span>() || path.<span class="hljs-built_in">back</span>()&lt;=nums[i]) &amp;&amp; uset.<span class="hljs-built_in">find</span>(nums[i])==uset.<span class="hljs-built_in">end</span>())&#123;<br>        uset.<span class="hljs-built_in">insert</span>(nums[i]);<br>        path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>        <span class="hljs-built_in">dfs</span>(nums,i+<span class="hljs-number">1</span>);<br>        path.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>方法二</strong> 或者是找到不符合要求不能加入路径中的数, 跳过</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start; i&lt;nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    <span class="hljs-keyword">if</span> ((!path.<span class="hljs-built_in">empty</span>() &amp;&amp; nums[i] &lt; path.<span class="hljs-built_in">back</span>()) || uset.<span class="hljs-built_in">find</span>(nums[i]) != uset.<span class="hljs-built_in">end</span>())<br>        <span class="hljs-keyword">continue</span>;<br>    uset.<span class="hljs-built_in">insert</span>(nums[i]); <br>    path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>    <span class="hljs-built_in">backtracking</span>(nums, i + <span class="hljs-number">1</span>);<br>    path.<span class="hljs-built_in">pop_back</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>整体代码如下</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; result;<br>    vector&lt;<span class="hljs-type">int</span>&gt; path;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> start)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(path.<span class="hljs-built_in">size</span>()&gt;=<span class="hljs-number">2</span>)          <span class="hljs-comment">// 长度大于2的序列</span><br>            result.<span class="hljs-built_in">push_back</span>(path); <span class="hljs-comment">// 记录</span><br>        <span class="hljs-keyword">if</span>(start==nums.<span class="hljs-built_in">size</span>())      <span class="hljs-comment">// 如果寻找的索引值超过数组</span><br>            <span class="hljs-keyword">return</span>;                 <span class="hljs-comment">// 退出</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; uset;    <span class="hljs-comment">// 创建set用于在本层中去重</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;nums.<span class="hljs-built_in">size</span>(); i++)&#123;<br>            <span class="hljs-keyword">if</span>((path.<span class="hljs-built_in">empty</span>() || path.<span class="hljs-built_in">back</span>()&lt;=nums[i]) &amp;&amp; uset.<span class="hljs-built_in">find</span>(nums[i])==uset.<span class="hljs-built_in">end</span>())&#123;       <span class="hljs-comment">// 找到符合要求的nums[i]</span><br>                uset.<span class="hljs-built_in">insert</span>(nums[i]);       <span class="hljs-comment">// 加入set </span><br>                path.<span class="hljs-built_in">push_back</span>(nums[i]);<br>                <span class="hljs-built_in">dfs</span>(nums,i+<span class="hljs-number">1</span>);<br>                path.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">findSubsequences</span>(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums) &#123;<br>        <span class="hljs-built_in">dfs</span>(nums,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>力扣刷题</tag>
      
      <tag>Java转C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈和队列(使用C++实现)</title>
    <link href="/2023/08/31/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/08/31/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 😲示例</h3><blockquote><p>栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::stack&lt;<span class="hljs-type">int</span>&gt; myStack;<br><br>    <span class="hljs-comment">// 入栈</span><br>    myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    myStack.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 访问栈顶元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Top element: &quot;</span> &lt;&lt; myStack.<span class="hljs-built_in">top</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 出栈</span><br>    myStack.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">// 检查栈是否为空</span><br>    <span class="hljs-keyword">if</span> (myStack.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Stack is empty&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Stack is not empty&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>队列</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; myQueue;<br><br>    <span class="hljs-comment">// 入队</span><br>    myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">1</span>);<br>    myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">2</span>);<br>    myQueue.<span class="hljs-built_in">push</span>(<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// 访问队首元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Front element: &quot;</span> &lt;&lt; myQueue.<span class="hljs-built_in">front</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 出队</span><br>    myQueue.<span class="hljs-built_in">pop</span>();<br><br>    <span class="hljs-comment">// 检查队列是否为空</span><br>    <span class="hljs-keyword">if</span> (myQueue.<span class="hljs-built_in">empty</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Queue is empty&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Queue is not empty&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些疑问解答"><a class="markdownIt-Anchor" href="#一些疑问解答"></a> 🤔一些疑问解答</h3><h4 id="pop函数是否可以返回值"><a class="markdownIt-Anchor" href="#pop函数是否可以返回值"></a> <code>pop()</code>函数是否可以返回值?</h4><blockquote><p>C++中pop()不能返回值, 只是删除一个元素而已, 这也符合最基本的弹出功能, 想要查看元素, 栈<code>stack</code>使用<code>top()</code>, 队列<code>queue</code>使用<code>front()</code></p></blockquote><h3 id="力扣刷题"><a class="markdownIt-Anchor" href="#力扣刷题"></a> 💪力扣刷题</h3><h4 id="232-用栈实现队列"><a class="markdownIt-Anchor" href="#232-用栈实现队列"></a> 232. 用栈实现队列</h4><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/">力扣传送门</a></p><blockquote><p>入栈操作都放到<code>stack_in</code>里面, 查看栈顶或者弹出操作, 都放到另一个<code>stack_out</code>中, 第二个栈由第一个栈一个一个弹出所填充, 所哟它的弹出顺序使相反的, 两个栈都是后进先出, 两个栈串联起来就是先进先出</p></blockquote><p><img src="https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif" alt="" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    stack&lt;<span class="hljs-type">int</span>&gt; in;<br>    stack&lt;<span class="hljs-type">int</span>&gt; out;<br>    <span class="hljs-built_in">MyQueue</span>() &#123;<br><br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        in.<span class="hljs-built_in">push</span>(x);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!out.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> a = out.<span class="hljs-built_in">top</span>();<br>            out.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">int</span> a;<br>            <span class="hljs-keyword">while</span>(!in.<span class="hljs-built_in">empty</span>())&#123;<br>                a = in.<span class="hljs-built_in">top</span>();<br>                in.<span class="hljs-built_in">pop</span>();<br>                out.<span class="hljs-built_in">push</span>(a);<br>            &#125;<br>            a = out.<span class="hljs-built_in">top</span>();<br>            out.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!out.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">top</span>();<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">while</span>(!in.<span class="hljs-built_in">empty</span>())&#123;<br>                <span class="hljs-type">int</span> a = in.<span class="hljs-built_in">top</span>();<br>                in.<span class="hljs-built_in">pop</span>();<br>                out.<span class="hljs-built_in">push</span>(a);<br>            &#125;<br>            <span class="hljs-keyword">return</span> out.<span class="hljs-built_in">top</span>();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> in.<span class="hljs-built_in">empty</span>() &amp;&amp; out.<span class="hljs-built_in">empty</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MyQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MyQueue* obj = new MyQueue();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * int param_2 = obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;peek();</span><br><span class="hljs-comment"> * bool param_4 = obj-&gt;empty();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h4 id="1047-删除字符串中的所有相邻重复项"><a class="markdownIt-Anchor" href="#1047-删除字符串中的所有相邻重复项"></a> 1047. 删除字符串中的所有相邻重复项</h4><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> delete_num = <span class="hljs-number">0</span>;<br>        stack&lt;<span class="hljs-type">char</span>&gt; st;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">empty</span>())<br>                st.<span class="hljs-built_in">push</span>(s[i]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(st.<span class="hljs-built_in">top</span>()==s[i])&#123;<br>                st.<span class="hljs-built_in">pop</span>();<br>                delete_num+=<span class="hljs-number">2</span>;    <br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                st.<span class="hljs-built_in">push</span>(s[i]);<br>        &#125;<br>        s.<span class="hljs-built_in">resize</span>(len-delete_num);<br>        len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=len<span class="hljs-number">-1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;<br>            s[i] = st.<span class="hljs-built_in">top</span>();<br>            st.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="20-有效的括号"><a class="markdownIt-Anchor" href="#20-有效的括号"></a> 20. 有效的括号</h4><p><a href="https://leetcode.cn/problems/valid-parentheses/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isValid</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">char</span>&gt; myStack;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> a : s)&#123;<br>            <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;(&#x27;</span> || a==<span class="hljs-string">&#x27;[&#x27;</span> || a==<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                myStack.<span class="hljs-built_in">push</span>(a);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(myStack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;)&#x27;</span> &amp;&amp; myStack.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;(&#x27;</span>)<br>                myStack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;]&#x27;</span> &amp;&amp; myStack.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;[&#x27;</span>)<br>                myStack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a==<span class="hljs-string">&#x27;&#125;&#x27;</span> &amp;&amp; myStack.<span class="hljs-built_in">top</span>()==<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>                myStack.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(myStack.<span class="hljs-built_in">empty</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="150-逆波兰表达式求值"><a class="markdownIt-Anchor" href="#150-逆波兰表达式求值"></a> 150. 逆波兰表达式求值</h4><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">evalRPN</span><span class="hljs-params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;<br>        stack&lt;<span class="hljs-type">int</span>&gt; s;               <span class="hljs-comment">// 栈s用于存数字</span><br>        <span class="hljs-type">int</span> len = tokens.<span class="hljs-built_in">size</span>();    <span class="hljs-comment">// 向量长度</span><br>        <span class="hljs-type">int</span> a,b;                    <span class="hljs-comment">// 用于保存取出来的两个数, 提前创建变量, 防止在循环中反复创建变量浪费时间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;+&quot;</span>)&#123;         <span class="hljs-comment">// +</span><br>                a = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                b = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                s.<span class="hljs-built_in">push</span>(a+b);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;-&quot;</span>)&#123;   <span class="hljs-comment">// -</span><br>                a = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                b = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                s.<span class="hljs-built_in">push</span>(b-a);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;*&quot;</span>)&#123;   <span class="hljs-comment">// *</span><br>                a = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                b = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                s.<span class="hljs-built_in">push</span>(a*b);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(tokens[i]==<span class="hljs-string">&quot;/&quot;</span>)&#123;   <span class="hljs-comment">// /</span><br>                a = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                b = s.<span class="hljs-built_in">top</span>();<br>                s.<span class="hljs-built_in">pop</span>();<br>                s.<span class="hljs-built_in">push</span>(b/a);<br>            &#125;<span class="hljs-keyword">else</span>&#123;                      <span class="hljs-comment">// 遇到数字需要转换</span><br>                s.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">turn_to_num</span>(tokens[i]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-built_in">top</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">turn_to_num</span><span class="hljs-params">(string s)</span></span>&#123;          <span class="hljs-comment">// 将字符串转换为数字</span><br>        <span class="hljs-type">int</span> start = (s[<span class="hljs-number">0</span>]==<span class="hljs-string">&#x27;-&#x27;</span>)?<span class="hljs-number">1</span>:<span class="hljs-number">0</span>;    <span class="hljs-comment">// 如果是负数则从索引为1的位置开始表示数字部分</span><br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();             <span class="hljs-comment">// 字符串长度</span><br>        <span class="hljs-type">int</span> num = <span class="hljs-number">0</span>;                    <span class="hljs-comment">// 记录解析到的数字, 会随着解析的位数增加而增加</span><br>        <span class="hljs-type">int</span> a;                          <span class="hljs-comment">// 用于保存某一位的数字, 提前创建防止在循环中反复创建浪费时间</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=start; i&lt;len; i++)&#123;<br>            a = s[i]-<span class="hljs-string">&#x27;0&#x27;</span>;               <span class="hljs-comment">// 第i位数字</span><br>            num = num*<span class="hljs-number">10</span>+a;             <span class="hljs-comment">// num*10+a为新的数字</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> (start==<span class="hljs-number">1</span>)?(<span class="hljs-number">0</span>-num):num;  <span class="hljs-comment">// 返回数字, 注意正负</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="347-前-k-个高频元素"><a class="markdownIt-Anchor" href="#347-前-k-个高频元素"></a> 347. 前 K 个高频元素</h4><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>力扣刷题</tag>
      
      <tag>Java转C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字符串(使用C++实现)</title>
    <link href="/2023/08/16/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <url>/2023/08/16/%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 😲示例</h3><p>在C++中，可以使用标准库中的string类来进行字符串的操作。下面是一些常见的字符串操作：</p><ol><li><p>字符串的创建和初始化：</p><ul><li>使用赋值运算符初始化字符串：<code>string str = &quot;Hello&quot;;</code></li><li>使用构造函数初始化字符串：<code>string str(&quot;Hello&quot;);</code></li></ul></li><li><p>字符串的拼接：</p><ul><li>使用加号运算符：<code>string str1 = &quot;Hello&quot;; string str2 = &quot;World&quot;; string result = str1 + str2;</code></li><li>使用append()函数：<code>string str1 = &quot;Hello&quot;; string str2 = &quot;World&quot;; str1.append(str2);</code></li></ul><blockquote><p>需要注意的是，<code>append()</code>函数会修改调用它的字符串对象，而不会创建一个新的字符串对象。</p></blockquote></li><li><p>字符串的比较：</p><ul><li>使用比较运算符：<code>string str1 = &quot;Hello&quot;; string str2 = &quot;World&quot;; if (str1 == str2) &#123; /* 字符串相等 */ &#125;</code></li><li>使用compare()函数：<code>string str1 = &quot;Hello&quot;; string str2 = &quot;World&quot;; if (str1.compare(str2) == 0) &#123; /* 字符串相等 */ &#125;</code></li></ul></li><li><p>字符串的长度：</p><ul><li>使用size()函数：<code>string str = &quot;Hello&quot;; int length = str.size();</code></li></ul></li><li><p>字符串的查找和替换：</p><ul><li>查找单个字符：<code>string str = &quot;hello&quot;; char a = str[0];</code></li><li>使用find()函数查找子串：<code>string str = &quot;Hello World&quot;; int pos = str.find(&quot;World&quot;);</code></li><li>使用replace()函数替换子串：<code>string str = &quot;Hello World&quot;; str.replace(6, 5, &quot;C++&quot;);</code></li></ul></li><li><p>字符串的截取和分割：</p><ul><li>使用substr()函数截取子串：<code>string str = &quot;Hello World&quot;; string sub = str.substr(6, 5);</code></li><li>使用stringstream类分割字符串：<code>string str = &quot;Hello,World,C++&quot;; stringstream ss(str); string token; while (getline(ss, token, ',')) &#123; /* 分割字符串 */ &#125;</code></li></ul></li></ol><h3 id="一些疑问解答"><a class="markdownIt-Anchor" href="#一些疑问解答"></a> 🤔一些疑问解答</h3><h4 id="字符串不算是基本数据类型-那么能不能想vector那样改变大小呢"><a class="markdownIt-Anchor" href="#字符串不算是基本数据类型-那么能不能想vector那样改变大小呢"></a> 字符串不算是基本数据类型, 那么能不能想vector那样改变大小呢?</h4><blockquote><p>可以, 使用<code>resize()</code>函数可以改变大小, 将会再数组后面扩充空白空间</p></blockquote><h4 id="resize函数改变大小的一些细节-比如增加长度的字符串是从前面增加还是后面-增加的内容是随机的还是有默认值"><a class="markdownIt-Anchor" href="#resize函数改变大小的一些细节-比如增加长度的字符串是从前面增加还是后面-增加的内容是随机的还是有默认值"></a> <code>resize()</code>函数改变大小的一些细节, 比如增加长度的字符串是从前面增加还是后面, 增加的内容是随机的还是有默认值</h4><blockquote><p>在C++中，<code>std::string</code>是一个用于处理字符串的标准库类。<code>std::string</code>类提供了许多有用的成员函数，其中之一是<code>resize()</code>函数。</p></blockquote><blockquote><p><code>resize()</code>函数用于改变<code>std::string</code>对象的大小，即修改字符串的长度。它接受一个参数，该参数指定了调整后的字符串长度。</p></blockquote><blockquote><p><code>resize()</code>函数有两种用法：</p></blockquote><ol><li><p>如果指定的长度大于当前字符串的长度，<code>resize()</code>函数将在末尾添加足够数量的字符来达到指定的长度。新添加的字符将被初始化为默认值，即空字符（<code>'\0'</code>）。<br />例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>str.<span class="hljs-built_in">resize</span>(<span class="hljs-number">8</span>); <span class="hljs-comment">// 将字符串长度调整为8</span><br>std::cout &lt;&lt; str; <span class="hljs-comment">// 输出：Hello\0\0\0</span><br></code></pre></td></tr></table></figure></li><li><p>如果指定的长度小于当前字符串的长度，<code>resize()</code>函数将截断字符串，使其长度符合指定的长度。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>str.<span class="hljs-built_in">resize</span>(<span class="hljs-number">5</span>); <span class="hljs-comment">// 将字符串长度调整为5</span><br>std::cout &lt;&lt; str; <span class="hljs-comment">// 输出：Hello</span><br></code></pre></td></tr></table></figure></li></ol><blockquote><p>此外，还可以使用<code>resize()</code>函数的第二个可选参数来指定新添加字符的值</p></blockquote><p>例如：</p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string str = <span class="hljs-string">&quot;Hello&quot;</span>;<br>str.<span class="hljs-built_in">resize</span>(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;!&#x27;</span>); <span class="hljs-comment">// 将字符串长度调整为8，并用&#x27;!&#x27;字符填充</span><br>std::cout &lt;&lt; str; <span class="hljs-comment">// 输出：Hello!!!</span><br></code></pre></td></tr></table></figure><h3 id="力扣刷题"><a class="markdownIt-Anchor" href="#力扣刷题"></a> 💪力扣刷题</h3><h4 id="344-反转字符串"><a class="markdownIt-Anchor" href="#344-反转字符串"></a> 344. 反转字符串</h4><p><a href="https://leetcode.cn/problems/reverse-string/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(vector&lt;<span class="hljs-type">char</span>&gt;&amp; s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len/<span class="hljs-number">2</span>; i++)&#123;<br>            <span class="hljs-built_in">swap</span>(s[i],s[len-i<span class="hljs-number">-1</span>]);<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="541-反转字符串-ii"><a class="markdownIt-Anchor" href="#541-反转字符串-ii"></a> 541. 反转字符串 II</h4><p><a href="https://leetcode.cn/problems/reverse-string-ii/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseStr</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> left,right;<br>        <span class="hljs-type">int</span> flag = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(flag&lt;len)&#123;<br>            left = flag;<br>            <span class="hljs-keyword">while</span>(count&lt;<span class="hljs-number">2</span>*k &amp;&amp; flag&lt;len)&#123;<br>                count++;<br>                flag++;<br>            &#125;<br>            right = left+<span class="hljs-built_in">min</span>(count,k)<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>                <span class="hljs-built_in">swap</span>(s[left++],s[right--]);<br>            &#125;<br>            count = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剑指-offer-05-替换空格"><a class="markdownIt-Anchor" href="#剑指-offer-05-替换空格"></a> 剑指 Offer 05. 替换空格</h4><p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/description/">力扣传送门</a></p><blockquote><p>先数出有多少个空格, 再增加字符串的大小<br />新的字符串使用两个指针从后往前改造, 前面的给后面提供值</p></blockquote><p><img src="https://code-thinking.cdn.bcebos.com/gifs/%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC.gif" alt="" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">replaceSpace</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i:s)<br>            <span class="hljs-keyword">if</span>(i==<span class="hljs-string">&#x27; &#x27;</span>)<br>                count++;<br>        <span class="hljs-type">int</span> left = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        s.<span class="hljs-built_in">resize</span>(s.<span class="hljs-built_in">size</span>()+count*<span class="hljs-number">2</span>);<br>        <span class="hljs-type">int</span> right = s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(left!=right)&#123;<br>            <span class="hljs-keyword">if</span>(s[left]!=<span class="hljs-string">&#x27; &#x27;</span>)<br>                s[right--] = s[left--];<br>            <span class="hljs-keyword">else</span>&#123;<br>                s[right--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                s[right--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                s[right--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                left--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="151-反转字符串中的单词"><a class="markdownIt-Anchor" href="#151-反转字符串中的单词"></a> 151. 反转字符串中的单词</h4><p><a href="https://leetcode.cn/problems/reverse-words-in-a-string/">力扣传送门</a></p><blockquote><ol><li>去掉头尾和中间的多余空格</li><li>把整个字符串反转</li><li>把每个单词依次反转</li></ol></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>&#123;<br>        <span class="hljs-type">int</span> len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// left定位第一个单词的头</span><br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(left&lt;len &amp;&amp; s[left]==<span class="hljs-string">&#x27; &#x27;</span>)<br>        left++;<br>        <span class="hljs-comment">// right定位到最后一个单词的尾</span><br>        <span class="hljs-type">int</span> right = len<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(right&gt;left &amp;&amp; s[right]==<span class="hljs-string">&#x27; &#x27;</span>)<br>        right--;<br>        <span class="hljs-comment">// 统计中间有多少单词和空格, 其中连续空格只记一次</span><br>        <span class="hljs-type">int</span> flag = left;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(flag&lt;=right)&#123;<br>            <span class="hljs-keyword">if</span>(s[flag]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;   <span class="hljs-comment">// 不是空格</span><br>                count++;<br>                flag++;<br>&#125;<br>            <span class="hljs-keyword">else</span>&#123;               <span class="hljs-comment">// 是空格</span><br>                count++;        <span class="hljs-comment">// 记一次</span><br>                <span class="hljs-keyword">while</span>(flag &lt;= right &amp;&amp; s[flag]==<span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-comment">// 找到下一个单词的头</span><br>                flag++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 把长的字符串搬移到前count个位置上</span><br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>, fast=left;<br>        <span class="hljs-keyword">while</span>(fast&lt;=right)&#123;<br>            <span class="hljs-keyword">if</span>(s[fast]!=<span class="hljs-string">&#x27; &#x27;</span>)&#123;<br>                s[slow] = s[fast];<br>                slow++;<br>                fast++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                s[slow] = s[fast];<br>                slow++;<br>                <span class="hljs-keyword">while</span>(fast&lt;=right &amp;&amp; s[fast]==<span class="hljs-string">&#x27; &#x27;</span>)<br>                fast++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 只留下前count个位置</span><br>        s.<span class="hljs-built_in">resize</span>(count);<br>        <span class="hljs-comment">// 反转整个字符串</span><br>        len = s.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len/<span class="hljs-number">2</span>; i++)<br>            <span class="hljs-built_in">swap</span>(s[i],s[len-i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-comment">// 把每个单词分别反转</span><br>        fast = <span class="hljs-number">0</span>;           <span class="hljs-comment">// fast定位到每一个单词的尾的后一个, 从0开始向后移动</span><br>        <span class="hljs-keyword">while</span>(fast&lt;len)&#123;<br>            slow = fast;                    <span class="hljs-comment">// slow定位到每一个单词的头</span><br>            <span class="hljs-keyword">while</span>(fast&lt;len &amp;&amp; s[fast]!=<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment">// fast定位到每一个单词的尾的后一个</span><br>                fast++;<br>            <span class="hljs-type">int</span> range = fast-slow;          <span class="hljs-comment">// 单词的范围</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;range/<span class="hljs-number">2</span>; i++)&#123;   <span class="hljs-comment">// 反转单词</span><br>                <span class="hljs-built_in">swap</span>(s[slow+i],s[fast-i<span class="hljs-number">-1</span>]);<br>&#125;<br>            fast++;                         <span class="hljs-comment">// fast向后移动一个, 移动到下一个单词的头</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="剑指-offer-58-ii-左旋转字符串"><a class="markdownIt-Anchor" href="#剑指-offer-58-ii-左旋转字符串"></a> 剑指 Offer 58 - II. 左旋转字符串</h4><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 还没做</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>力扣刷题</tag>
      
      <tag>Java转C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希表(使用C++实现)</title>
    <link href="/2023/08/16/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2023/08/16/%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 😲示例</h3><blockquote><p>主要使用map和set, 如果是键值对结构就使用map, 如果不是键值对结构但是需要去重, 就使用set</p></blockquote><blockquote><p>unordered_set是C++标准库中的一个容器，用于存储唯一的元素集合，所以需要去重的数据可以用它来存, 元素的存储顺序是无序的。下面是unordered_set的基本用法、常见函数和遍历方法：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1. 包含头文件：</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><br><span class="hljs-comment">// 2. 声明和初始化unordered_set：</span><br>std::unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet; <span class="hljs-comment">// 声明一个空的unordered_set</span><br>std::unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">// 声明并初始化一个unordered_set</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-function">std::unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mySet</span><span class="hljs-params">(vec.begin(), vec.end())</span></span>; <span class="hljs-comment">// 使用迭代器范围构造unordered_set</span><br>std::unordered_set&lt;<span class="hljs-type">int</span>&gt; mySet1 = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br><span class="hljs-function">std::unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mySet2</span><span class="hljs-params">(mySet1)</span></span>; <span class="hljs-comment">// 使用拷贝构造函数创建一个与已有unordered_set相同的副本</span><br><br><br><span class="hljs-comment">// 3. 插入元素：</span><br>mySet.<span class="hljs-built_in">insert</span>(<span class="hljs-number">4</span>); <span class="hljs-comment">// 插入单个元素</span><br>mySet.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;); <span class="hljs-comment">// 插入多个元素</span><br><br><br><span class="hljs-comment">// 4. 删除元素：</span><br>mySet.<span class="hljs-built_in">erase</span>(<span class="hljs-number">3</span>); <span class="hljs-comment">// 删除指定元素</span><br>mySet.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清空unordered_set</span><br><br><br><span class="hljs-comment">// 5. 查找元素：</span><br><span class="hljs-keyword">auto</span> it = mySet.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 查找指定元素，返回迭代器</span><br><span class="hljs-comment">// 如果没有找到就会返回最后一个的下一个指针</span><br><span class="hljs-keyword">if</span> (it != mySet.<span class="hljs-built_in">end</span>()) &#123;<br>    <span class="hljs-comment">// 找到了元素</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 没有找到元素</span><br>&#125;<br><br><br><span class="hljs-comment">// 6. 判断元素是否存在：</span><br><span class="hljs-keyword">if</span> (mySet.<span class="hljs-built_in">count</span>(<span class="hljs-number">3</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 元素存在</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 元素不存在</span><br>&#125;<br><br><br><span class="hljs-comment">// 7. 获取unordered_set的大小：</span><br><span class="hljs-type">int</span> size = mySet.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 返回unordered_set中元素的个数</span><br><br><br><span class="hljs-comment">// 8. 遍历unordered_set：</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = mySet.<span class="hljs-built_in">begin</span>(); it != mySet.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>    <span class="hljs-comment">// 使用迭代器访问unordered_set中的元素</span><br>&#125;<br><br><span class="hljs-comment">// 或者使用范围-based for循环（C++11及以上版本）</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; element : mySet) &#123;<br>    <span class="hljs-comment">// 使用元素访问unordered_set中的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>unordered_map的用法和常用函数</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个unordered_map</span><br>    std::unordered_map&lt;<span class="hljs-type">int</span>, std::string&gt; myMap;<br><br>    <span class="hljs-comment">// 插入键值对</span><br>    myMap.<span class="hljs-built_in">insert</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-string">&quot;apple&quot;</span>&#125;);<br>    myMap[<span class="hljs-number">2</span>,<span class="hljs-string">&quot;orange&quot;</span>];<br>    <br><br>    <span class="hljs-comment">// 访问元素</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Value at key 2: &quot;</span> &lt;&lt; myMap[<span class="hljs-number">2</span>] &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 检查键是否存在, 使用count()</span><br>    <span class="hljs-keyword">if</span> (myMap.<span class="hljs-built_in">count</span>(<span class="hljs-number">2</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 2 exists&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查键是否存在, 使用find()</span><br>    <span class="hljs-keyword">auto</span> it = myMap.<span class="hljs-built_in">find</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">if</span> (it != myMap.<span class="hljs-built_in">end</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 2 found. Value: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key 2 not found.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 修改元素的值</span><br>    myMap[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;grape&quot;</span>;<br><br>    <span class="hljs-comment">// 删除元素</span><br>    myMap.<span class="hljs-built_in">erase</span>(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-comment">// 遍历unordered_map, 指针的first和second可以返回键和值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; pair : myMap) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Key: &quot;</span> &lt;&lt; pair.first &lt;&lt; <span class="hljs-string">&quot;, Value: &quot;</span> &lt;&lt; pair.second &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意使用了两种查找auto, <code>auto it = myMap.find(2);</code>返回的是迭代器指针, 如果需要成员变量需要使用<code>-&gt;</code>, 而<code>const auto&amp; pair : myMap</code>使用了迭代器的引用类型, 使用指针初始化引用类型, 引用类型的使用和原变量一样, 直接使用<code>.</code></p></blockquote><h3 id="一些疑问解答"><a class="markdownIt-Anchor" href="#一些疑问解答"></a> 🤔一些疑问解答</h3><h4 id="const-auto-pair-mymap中必须加const吗"><a class="markdownIt-Anchor" href="#const-auto-pair-mymap中必须加const吗"></a> <code>const auto&amp; pair : myMap</code>中必须加<code>const</code>吗?</h4><blockquote><p>在遍历<code>unordered_map</code>时，使用<code>const auto&amp; pair : myMap</code>是一种常见的做法，但并不是必须的<br />使用<code>const auto&amp;</code>可以确保你不会意外地修改<code>unordered_map</code>中的元素。这是一种安全的做法<br />如果需要再遍历的过程中修改或删除一些值, 那么可以使用<code>auto&amp;</code>而不是<code>const auto&amp;</code></p></blockquote><h4 id="为什么有的哈希表题目并没有用哈希表来做而是用数组"><a class="markdownIt-Anchor" href="#为什么有的哈希表题目并没有用哈希表来做而是用数组"></a> 为什么有的哈希表题目并没有用哈希表来做而是用数组?</h4><blockquote><p>如果题目中确实需要查每个元素, 但是元素的取值范围并不大, <strong>而且索引可以直接算出来不需要遍历</strong>, 那么就可以直接用数组, 比如<a href="https://leetcode.cn/problems/valid-anagram/">力扣题目242</a></p></blockquote><h3 id="力扣刷题"><a class="markdownIt-Anchor" href="#力扣刷题"></a> 💪力扣刷题</h3><h4 id="242-有效的字母异位词"><a class="markdownIt-Anchor" href="#242-有效的字母异位词"></a> 242. 有效的字母异位词</h4><p><a href="https://leetcode.cn/problems/valid-anagram/">力扣传送门</a></p><blockquote><p>这个需要一个哈希表记录所有字母的出现次数, 但是由于题目中只出现26个字母, 所以也可以直接使用数组记录字母出现次数</p></blockquote><blockquote><p>如果s中出现字母, 则再记录表中+1, 如果t表中出现字母, 则再记录表中-1, 最后只需要记录表中有没有非0元素</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        <span class="hljs-type">int</span> letter[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;s.<span class="hljs-built_in">size</span>(); i++)<br>            letter[s[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;t.<span class="hljs-built_in">size</span>(); i++)<br>            letter[t[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">26</span>; i++)<br>            <span class="hljs-keyword">if</span>(letter[i]!=<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="349-两个数组的交集"><a class="markdownIt-Anchor" href="#349-两个数组的交集"></a> 349. 两个数组的交集</h4><p><a href="https://leetcode.cn/problems/intersection-of-two-arrays/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">intersection</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2)</span> </span>&#123;<br>        <span class="hljs-comment">// 收集nums1中出现的所有数并去重</span><br>        <span class="hljs-function">unordered_set&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(nums1.begin(),nums1.end())</span></span>;<br>        <span class="hljs-comment">// 结果集合也不能有重复, 所以先使用unordered_set, 随后转换为vector</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; rs;<br>        <span class="hljs-type">int</span> len = nums2.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-comment">// 遍历nums2, 如果找到了重复元素, 那么加入结果集合</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(data.<span class="hljs-built_in">find</span>(nums2[i])!=data.<span class="hljs-built_in">end</span>())<br>                rs.<span class="hljs-built_in">insert</span>(nums2[i]);<br>        &#125;<br>        <span class="hljs-comment">// 转换为vector并返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(rs.<span class="hljs-built_in">begin</span>(),rs.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="202-快乐数"><a class="markdownIt-Anchor" href="#202-快乐数"></a> 202. 快乐数</h4><p><a href="https://leetcode.cn/problems/happy-number/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">int</span> new_n=n, sum;           <span class="hljs-comment">// 用于保存每一次的数字本身和数字各位上的平方和</span><br>        unordered_set&lt;<span class="hljs-type">int</span>&gt; sums;    <span class="hljs-comment">// 用于保存出现过的数字, 防止无限循环导致超时</span><br>        <span class="hljs-keyword">while</span>(new_n!=<span class="hljs-number">1</span>)&#123;            <span class="hljs-comment">// 只要没出现1就接着算</span><br>            <span class="hljs-type">int</span> k;                  <span class="hljs-comment">// k用于取出各个位上的数字</span><br>            sum = <span class="hljs-number">0</span>;                <span class="hljs-comment">// sum用于存数字各个位上的平方和</span><br>            <span class="hljs-keyword">while</span>(new_n!=<span class="hljs-number">0</span>)&#123;        <span class="hljs-comment">// 没去完数字所有位就接着取</span><br>                k = new_n%<span class="hljs-number">10</span>;<br>                sum+=k*k;<br>                new_n/=<span class="hljs-number">10</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(sums.<span class="hljs-built_in">find</span>(sum)!=sums.<span class="hljs-built_in">end</span>())  <span class="hljs-comment">// 如果发现了重复</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;               <span class="hljs-comment">// 返回false</span><br>            <span class="hljs-keyword">else</span>                            <span class="hljs-comment">// 否则就把这一次的数字存进集合中</span><br>                sums.<span class="hljs-built_in">insert</span>(sum);<br>            new_n = sum;                    <span class="hljs-comment">// 这一次的平方和是下一次的数字</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;                        <span class="hljs-comment">// 如果跳出循环说明找到了1</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="1-两数之和"><a class="markdownIt-Anchor" href="#1-两数之和"></a> 1. 两数之和</h4><p><a href="https://leetcode.cn/problems/two-sum/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">twoSum</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rs</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span>;              <span class="hljs-comment">// 用于保存结果</span><br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; my_map;  <span class="hljs-comment">// 用于保存没一个数字的下标</span><br>        <span class="hljs-type">int</span> len = nums.<span class="hljs-built_in">size</span>();          <span class="hljs-comment">// 存一下大小, 避免反复访问</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)        <span class="hljs-comment">// 存储没一个数的下标</span><br>            my_map[nums[i]] = i;        <span class="hljs-comment">// 数字为键, 下标为值</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;       <span class="hljs-comment">// 查找每一个数被target减去的差在不在数组中</span><br>            <span class="hljs-keyword">auto</span> it = my_map.<span class="hljs-built_in">find</span>(target-nums[i]);  <span class="hljs-comment">// 获取差的下标</span><br>            <span class="hljs-keyword">if</span>(it!=my_map.<span class="hljs-built_in">end</span>() &amp;&amp; it-&gt;second!=i)&#123;  <span class="hljs-comment">// 如果存在差, 并且不是自己</span><br>                rs[<span class="hljs-number">0</span>] = i;                          <span class="hljs-comment">// 存本身的下标</span><br>                rs[<span class="hljs-number">1</span>] = it-&gt;second;                 <span class="hljs-comment">// 存差的下标</span><br>                <span class="hljs-keyword">break</span>;                              <span class="hljs-comment">// 跳出循环</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rs;;                                 <span class="hljs-comment">// 返回结果</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="454-四数相加-ii"><a class="markdownIt-Anchor" href="#454-四数相加-ii"></a> 454. 四数相加 II</h4><p><a href="https://leetcode.cn/problems/4sum-ii/">力扣传送门</a></p><blockquote><p>先统计前两个数组的所有和, 用map, 键是和, 值是和出现的次数<br />再统计后两个数组的所有和, 不用新建map, 直接查之前的那个map里有没有相反数, 有的话结果就加上对应的情况数目</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums1, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums2, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums3, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums4)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; my_map;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:nums1)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j:nums2)&#123;<br>                my_map[i+j]++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:nums3)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j:nums4)&#123;<br>                <span class="hljs-keyword">if</span>(my_map.<span class="hljs-built_in">find</span>(<span class="hljs-number">0</span>-i-j)!=my_map.<span class="hljs-built_in">end</span>())&#123;<br>                    count+=my_map[<span class="hljs-number">0</span>-i-j];<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="383-赎金信"><a class="markdownIt-Anchor" href="#383-赎金信"></a> 383. 赎金信</h4><p><a href="https://leetcode.cn/problems/ransom-note/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">canConstruct</span><span class="hljs-params">(string ransomNote, string magazine)</span> </span>&#123;<br>        <span class="hljs-type">int</span> letter[<span class="hljs-number">26</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i:magazine)<br>            letter[i-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> i:ransomNote)<br>            letter[i-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i:letter)<br>            <span class="hljs-keyword">if</span>(i&lt;<span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="15-三数之和"><a class="markdownIt-Anchor" href="#15-三数之和"></a> 15. 三数之和</h4><p><a href="https://leetcode.cn/problems/3sum/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 还没做</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>力扣刷题</tag>
      
      <tag>Java转C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>骡儿往上瞧, 马儿向下看</title>
    <link href="/2023/08/12/%E9%AA%A1%E5%84%BF%E5%BE%80%E4%B8%8A%E7%9E%A7,%20%E9%A9%AC%E5%84%BF%E5%90%91%E4%B8%8B%E7%9C%8B/"/>
    <url>/2023/08/12/%E9%AA%A1%E5%84%BF%E5%BE%80%E4%B8%8A%E7%9E%A7,%20%E9%A9%AC%E5%84%BF%E5%90%91%E4%B8%8B%E7%9C%8B/</url>
    
    <content type="html"><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=743386061&bvid=BV17k4y1N71w&cid=1198243272&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><p><img src="https://s2.loli.net/2023/08/12/BXRmYIakKQ1tMg8.jpg" alt="" /></p>]]></content>
    
    
    <categories>
      
      <category>左翼思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>马克思主义</tag>
      
      <tag>人民史观</tag>
      
      <tag>阶级矛盾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组(使用C++实现)</title>
    <link href="/2023/08/12/%E6%95%B0%E7%BB%84/"/>
    <url>/2023/08/12/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="一些问题"><a class="markdownIt-Anchor" href="#一些问题"></a> 🤔一些问题</h3><h4 id="c中数组无法用变量定义大小-如何像java那样用变量控制数组大小"><a class="markdownIt-Anchor" href="#c中数组无法用变量定义大小-如何像java那样用变量控制数组大小"></a> C++中数组无法用变量定义大小, 如何像Java那样用变量控制数组大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> size = <span class="hljs-number">5</span>; <span class="hljs-comment">// 数组大小</span><br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[size]; <span class="hljs-comment">// 动态分配一个大小为size的int类型数组</span><br></code></pre></td></tr></table></figure><h4 id="应该如何遍历一个未知大小的数组呢"><a class="markdownIt-Anchor" href="#应该如何遍历一个未知大小的数组呢"></a> 应该如何遍历一个未知大小的数组呢?</h4><blockquote><p>C++中数组没有求大小的内置函数, 数组大小的求法: <code>sizeof(arr) / sizeof(arr[0])</code></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">int</span> size = <span class="hljs-built_in">sizeof</span>(arr) / <span class="hljs-built_in">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>    <span class="hljs-comment">// 访问数组元素 arr[i]</span><br>    <span class="hljs-comment">// 进行相应的操作</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="有没有类似java中的arraylist那样的可以方便插入删除获取length的线性表"><a class="markdownIt-Anchor" href="#有没有类似java中的arraylist那样的可以方便插入删除获取length的线性表"></a> 有没有类似Java中的ArrayList那样的可以方便插入,删除,获取length的线性表</h4><blockquote><p>在C++中，<code>&lt;vector&gt;</code>是一个标准库头文件，用于包含与向量容器相关的功能和类。向量是一种动态数组，可以在运行时调整大小，并提供了许多方便的操作和函数。</p></blockquote><blockquote><p>以下是一些<code>&lt;vector&gt;</code>头文件中常用的功能和用法：<br />创建向量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br>std::vector&lt;<span class="hljs-type">int</span>&gt; vec; <span class="hljs-comment">// 创建一个空的整数向量</span><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">double</span>&gt; <span class="hljs-title">vec2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>; <span class="hljs-comment">// 创建一个包含5个元素的双精度浮点数向量</span><br>std::vector&lt;std::string&gt; vec3 = &#123;<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>&#125;; <span class="hljs-comment">// 创建并初始化一个字符串向量</span><br></code></pre></td></tr></table></figure><blockquote><p>添加和访问元素：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 在向量末尾添加元素</span><br>vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">20</span>);<br><br><span class="hljs-type">int</span> firstElement = vec[<span class="hljs-number">0</span>]; <span class="hljs-comment">// 访问向量中的第一个元素</span><br><span class="hljs-type">int</span> lastElement = vec.<span class="hljs-built_in">back</span>(); <span class="hljs-comment">// 访问向量中的最后一个元素</span><br></code></pre></td></tr></table></figure><blockquote><p>获取向量的大小和遍历元素：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> size = vec.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// 获取向量的大小</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vec.<span class="hljs-built_in">size</span>(); i++) &#123;<br>    std::cout &lt;&lt; vec[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 遍历向量中的元素</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> element : vec) &#123;<br>    std::cout &lt;&lt; element &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <span class="hljs-comment">// 使用范围-based for 循环遍历向量中的元素</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>插入和删除元素：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">vec.<span class="hljs-built_in">insert</span>(vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>, <span class="hljs-number">30</span>); <span class="hljs-comment">// 在指定位置插入元素</span><br>vec.<span class="hljs-built_in">erase</span>(vec.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>); <span class="hljs-comment">// 删除指定位置的元素</span><br>vec.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// 清空向量中的所有元素</span><br></code></pre></td></tr></table></figure><blockquote><p>其他常用操作：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> isEmpty = vec.<span class="hljs-built_in">empty</span>(); <span class="hljs-comment">// 检查向量是否为空</span><br>vec.<span class="hljs-built_in">resize</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// 调整向量的大小为10</span><br>vec.<span class="hljs-built_in">pop_back</span>(); <span class="hljs-comment">// 删除向量中的最后一个元素</span><br>vec.<span class="hljs-built_in">sort</span>(); <span class="hljs-comment">// 对向量进行排序（需要包含&lt;algorithm&gt;头文件）</span><br></code></pre></td></tr></table></figure><h3 id="力扣刷题"><a class="markdownIt-Anchor" href="#力扣刷题"></a> 💪力扣刷题</h3><h4 id="704-二分查找"><a class="markdownIt-Anchor" href="#704-二分查找"></a> 704. 二分查找</h4><p><a href="https://leetcode.cn/problems/binary-search/">力扣传送门</a></p><blockquote><p>循环条件使用<code>begin&lt;=end</code>比较方便, 3个分支一定会进入一个, 只要没找到,<code>begin</code>或者<code>end</code>至少有一个发生变化</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">search</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-comment">// 使用闭区间[begin,end]缩小查找范围</span><br>        <span class="hljs-type">int</span> begin=<span class="hljs-number">0</span>, end=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> mid;<br>        <span class="hljs-keyword">while</span>(begin&lt;=end)&#123;<br>            mid = (begin+end)/<span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid]==target)       <span class="hljs-comment">// 先比较mid位置</span><br>                <span class="hljs-keyword">return</span> mid;             <span class="hljs-comment">// 比较成功直接返回</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target&gt;nums[mid])   <span class="hljs-comment">// 如果在左边</span><br>                begin = mid+<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span>                        <span class="hljs-comment">// 如果在右边</span><br>                end = mid<span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 没找到</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="27-移除元素"><a class="markdownIt-Anchor" href="#27-移除元素"></a> 27. 移除元素</h4><p><a href="https://leetcode.cn/problems/remove-element/">力扣传送门</a></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif" alt="Alt text" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 快慢指针, 快指针指向旧数组, 慢指针指向新数组, 旧数组的数据给新数组的对应位置赋值</span><br>        <span class="hljs-type">int</span> slow=<span class="hljs-number">0</span>, fast=<span class="hljs-number">0</span>, len = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span>(fast&lt;len)&#123;<br>            <span class="hljs-keyword">if</span>(nums[fast]==val)<br>                fast++;<br>            <span class="hljs-keyword">else</span>&#123;<br>                nums[slow] = nums[fast];<br>                slow++;<br>                fast++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="977-有序数组的平方"><a class="markdownIt-Anchor" href="#977-有序数组的平方"></a> 977. 有序数组的平方</h4><p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">力扣传送门</a></p><p><img src="https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif" alt="" /></p><blockquote><p>从两边到中间, 数字的平方依次减小</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sortedSquares</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>, j=nums.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>, k=j;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">rs</span><span class="hljs-params">(nums.size())</span></span>;<br>        <span class="hljs-keyword">while</span>(k&gt;=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[i]*nums[i]&gt;nums[j]*nums[j])&#123;<br>                rs[k] = nums[i]*nums[i];<br>                k--;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                rs[k] = nums[j]*nums[j];<br>                k--;<br>                j--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rs;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="209-长度最小的子数组"><a class="markdownIt-Anchor" href="#209-长度最小的子数组"></a> 209. 长度最小的子数组</h4><p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">力扣传送门</a></p><blockquote><p>记录最小值, 那么就需要预先赋值一个最大值, C++中的整型最大值为<code>INT32_MAX</code>,<code>INT32_MAX</code>是一个预定义的常量，不需要引入任何库来使用它。它是在标准的C++头文件<code>&lt;limits.h&gt;</code>或<code>&lt;cstdint&gt;</code>中定义的。只要包含其中一个头文件，就可以直接使用<code>INT32_MAX</code>常量，无需额外的库。以下是一个示例代码：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdint&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int32_t</span> maxInt = INT32_MAX;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;最大整数值：&quot;</span> &lt;&lt; maxInt &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用滑动窗口, 两个窗口闭区间内判断是否符合要求, 循环条件为窗口末端指针<code>j</code>遍历整个数组, 如果符合要求就通过移动窗口前端的指针<code>i</code>来逐步缩小窗口, 看看能缩小到什么程度, 如果缩小导致窗口内数字的和小于<code>target</code>, 那么就移动窗口后端指针<code>j</code>, 如果<code>j==nums.size()-1</code>但是和小于<code>target</code>, 那么要终止循环</p></blockquote><p><img src="https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif" alt="" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minSubArrayLen</span><span class="hljs-params">(<span class="hljs-type">int</span> target, vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> rs = INT32_MAX;<br>        <span class="hljs-comment">// 两个窗口指针</span><br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>,j=<span class="hljs-number">0</span>,len=nums.<span class="hljs-built_in">size</span>(),num=nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">while</span>(j&lt;len)&#123;<br>            <span class="hljs-keyword">if</span>(j==len<span class="hljs-number">-1</span> &amp;&amp; num&lt;target)  <span class="hljs-comment">// 已经到了最后一个数字但是不能继续后移j</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(j!=len<span class="hljs-number">-1</span> &amp;&amp; num&lt;target)&#123; <span class="hljs-comment">// 没有到达最后一个数字, 且需要后移j</span><br>                j++;<br>                num+=nums[j];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;                       <span class="hljs-comment">// num&gt;=target, 后移i</span><br>                rs = <span class="hljs-built_in">min</span>(rs,j-i+<span class="hljs-number">1</span>);<br>                num-=nums[i];<br>                i++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rs==INT32_MAX ? <span class="hljs-number">0</span> : rs;  <span class="hljs-comment">// 如果没找到符合要求的窗口那么返回0</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="59-螺旋矩阵-ii"><a class="markdownIt-Anchor" href="#59-螺旋矩阵-ii"></a> 59. 螺旋矩阵 II</h4><p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">力扣传送门</a></p><blockquote><p>方法很多, 主要考察对代码的掌控能力<br />思路一: 可以再写一个方法用于控制方向, 坐标(i,j)顺时针运动, 转变关系为(0,+1)-&gt;(+1,0)-&gt;(0,-1)-&gt;(-1,0), 循环条件使用一个计数的变量, 当他等于n<sup>2</sup>的时候就是终点<br />思路二: 用圈数控制循环, 每一圈的四个方向都写一遍, 其中如果n为基数, 最中间那个位置不太容易赋值, 放在最后判断n为奇数的时候赋值</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">generateMatrix</span>(<span class="hljs-type">int</span> n) &#123;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">rs</span>(n,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n,<span class="hljs-number">0</span>));<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">1</span>,loop=<span class="hljs-number">1</span>,end_loop=n/<span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">while</span>(loop&lt;=end_loop)&#123;<br>            <span class="hljs-type">int</span> from=loop<span class="hljs-number">-1</span>,end=n-loop;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=from,j=i;j&lt;end;j++)&#123;<br>                rs[i][j] = k;<br>                k++;    <br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=from,j=end;i&lt;end;i++)&#123;<br>                rs[i][j] = k;<br>                k++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=end,j=end;j&gt;from;j--)&#123;<br>                rs[i][j] = k;<br>                k++;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=end,j=from;i&gt;from;i--)&#123;<br>                rs[i][j] = k;<br>                k++;<br>            &#125;<br>            loop++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>)&#123;<br>            rs[n/<span class="hljs-number">2</span>][n/<span class="hljs-number">2</span>] = k;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rs;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>力扣刷题</tag>
      
      <tag>Java转C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表(使用C++实现)</title>
    <link href="/2023/08/11/%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/08/11/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="创建结点示例"><a class="markdownIt-Anchor" href="#创建结点示例"></a> 😲创建结点示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 单链表节点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;  <span class="hljs-comment">// 节点上存储的元素</span><br>    ListNode *next;  <span class="hljs-comment">// 指向下一个节点的指针</span><br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">NULL</span>) &#123;&#125;  <span class="hljs-comment">// 节点的构造函数</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 使用自定义构造函数初始化, 创建指针变量并开辟实体内存空间</span><br>    ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-comment">// 使用C++提供的默认构造函数, 然后通过赋值初始化</span><br>    ListNode* head = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>();<br>    head-&gt;val = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="一些疑问解答"><a class="markdownIt-Anchor" href="#一些疑问解答"></a> 🤔一些疑问解答</h3><h4 id="链表在插入删除之前必须找到需要插入删除的位置-那么为什么时间复杂度不是on而是o1"><a class="markdownIt-Anchor" href="#链表在插入删除之前必须找到需要插入删除的位置-那么为什么时间复杂度不是on而是o1"></a> 链表在插入删除之前必须找到需要插入删除的位置, 那么为什么时间复杂度不是O(n)而是O(1)</h4><blockquote><p>这个时间复杂度说的是找到之后的删除和插入操作, 而不包含找到这个位置所消耗的时间<br />线性表删除需要讲后面的数据往前移动一格, 插入需要后面的数据往后移动一格, 所以是O(n)<br />链表只需要将指针存储的内存位置信息改动一下即可, 没有移动操作所以是O(1)</p></blockquote><h4 id="c如何手动释放内存"><a class="markdownIt-Anchor" href="#c如何手动释放内存"></a> C++如何手动释放内存</h4><blockquote><p>Java、Python，就有自己的内存回收机制, C++最好自己手动释放内存<br /><code>delete</code>释放单个指针, <code>delete[]</code>释放指针数组</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// 动态分配一个int类型的对象</span><br><span class="hljs-comment">// 使用ptr</span><br><span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 释放内存</span><br></code></pre></td></tr></table></figure><p>如果使用<code>new[]</code>操作符动态分配了一个数组的内存，那么应该使用<code>delete[]</code>操作符来释放该内存。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]; <span class="hljs-comment">// 动态分配一个包含5个int类型元素的数组</span><br><span class="hljs-comment">// 使用arr</span><br><span class="hljs-keyword">delete</span>[] arr; <span class="hljs-comment">// 释放内存</span><br></code></pre></td></tr></table></figure><h3 id="力扣刷题"><a class="markdownIt-Anchor" href="#力扣刷题"></a> 💪力扣刷题</h3><h4 id="203-移除链表元素"><a class="markdownIt-Anchor" href="#203-移除链表元素"></a> 203. 移除链表元素</h4><p><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeElements</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个虚拟头节点, 防止后面分类讨论第一个节点究竟等不等于val</span><br>        ListNode* pre = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>        pre-&gt;next = head;<br>        <span class="hljs-comment">// 创建一个用于遍历的指针</span><br>        ListNode* temp = pre;<br>        <span class="hljs-keyword">while</span>(temp-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-comment">// 定位到val节点的前一个, 然后删除它, 同时删除内存</span><br>            <span class="hljs-keyword">if</span>(temp-&gt;next-&gt;val==val)&#123;<br>                ListNode* d = temp-&gt;next;<br>                temp-&gt;next = temp-&gt;next-&gt;next;<br>                <span class="hljs-keyword">delete</span> d;<br>            &#125;<br>            <span class="hljs-comment">// 删除完成不要后移指针, 下一轮再判断一次, 如果temp-&gt;next-&gt;val!=val再考虑后移, 否则可能漏掉节点没判断</span><br>            <span class="hljs-keyword">else</span>&#123;<br>                temp = temp-&gt;next;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="206-反转链表"><a class="markdownIt-Anchor" href="#206-反转链表"></a> 206. 反转链表</h4><p><a href="https://leetcode.cn/problems/reverse-linked-list/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        ListNode* pre = <span class="hljs-literal">nullptr</span>;<br>        ListNode* tmp = head;<br>        <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">nullptr</span>)&#123;<br>            ListNode* post = tmp-&gt;next;<br>            tmp-&gt;next = pre;<br>            pre = tmp;<br>            tmp = post;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="24-两两交换链表中的节点"><a class="markdownIt-Anchor" href="#24-两两交换链表中的节点"></a> 24. 两两交换链表中的节点</h4><p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建一个虚拟头指针</span><br>        ListNode* dummyhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        ListNode* tmp = dummyhead;<br>        ListNode* tmp2;<br>        ListNode* tmp3;<br>        <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">nullptr</span> &amp;&amp; tmp-&gt;next!=<span class="hljs-literal">nullptr</span> &amp;&amp; tmp-&gt;next-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-comment">// 记录两个位置</span><br>            tmp2 = tmp-&gt;next;<br>            tmp3 = tmp2-&gt;next-&gt;next;<br>            <span class="hljs-comment">// 核心的三个操作</span><br>            tmp-&gt;next = tmp-&gt;next-&gt;next;<br>            tmp-&gt;next-&gt;next = tmp2;<br>            tmp2-&gt;next = tmp3;<br>            <span class="hljs-comment">// tmp向后移动</span><br>            tmp = tmp2;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummyhead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>指针变量本身所占的内存空间会在其作用域结束时自动释放，无需手动删除, 如<code>tmp</code>,<code>tmp2</code>,<code>tmp3</code></p></blockquote><blockquote><p>实际上tmp不可能是空指针, 它只在后两个明确不是空指针的时候才进入循环, 每一轮循环结束的时候定位在后面第二个, 所以其实tmp不可能是空指针</p></blockquote><blockquote><p><code>tmp-&gt;next==nullptr</code>和<code>tmp-&gt;next-&gt;next==nullptr</code>的情况不用判断, 都只需要直接返回即可, 因为tmp后面只剩一个或者一个不剩都不需要操作, 直接返回即可</p></blockquote><h4 id="19-删除链表的倒数第-n-个结点"><a class="markdownIt-Anchor" href="#19-删除链表的倒数第-n-个结点"></a> 19. 删除链表的倒数第 N 个结点</h4><p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode* <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode* head, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 虚拟头节点, 避免分类讨论</span><br>        ListNode* dummyhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>,head);<br>        <span class="hljs-comment">// 双指针</span><br>        ListNode* tmp1 = dummyhead;<br>        ListNode* tmp2 = tmp1;<br>        <span class="hljs-comment">// 让两个指针中间间隙大小为n</span><br>        <span class="hljs-keyword">while</span>(n--&gt;<span class="hljs-number">0</span>)&#123;<br>            tmp2 = tmp2-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 同时向后移动, 知道后一个指针移动到最后一个</span><br>        <span class="hljs-keyword">while</span>(tmp2-&gt;next!=<span class="hljs-literal">nullptr</span>)&#123;<br>            tmp1 = tmp1-&gt;next;<br>            tmp2 = tmp2-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 前一个指针的位置进行删除操作</span><br>        ListNode* d = tmp1-&gt;next;<br>        tmp1-&gt;next = tmp1-&gt;next-&gt;next;<br>        <span class="hljs-keyword">delete</span> d;<br>        <span class="hljs-keyword">return</span> dummyhead-&gt;next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="面试题-0207-链表相交"><a class="markdownIt-Anchor" href="#面试题-0207-链表相交"></a> 面试题 02.07. 链表相交</h4><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/">力扣传送门</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode *headA, ListNode *headB)</span> </span>&#123;<br>        <span class="hljs-comment">// 定义两个指针用于指向长链表和短链表, 暂且认为A长B短, 统计完长度如若不对再交换地址</span><br>        ListNode* longOne = headA;<br>        ListNode* shortOne = headB;<br>        <span class="hljs-comment">// 统计两个链表长度</span><br>        <span class="hljs-type">int</span> longLen=<span class="hljs-number">0</span>, shortLen=<span class="hljs-number">0</span>;<br>        ListNode* tmp = headA;<br>        <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>            longLen++;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        tmp = headB;<br>        <span class="hljs-keyword">while</span>(tmp!=<span class="hljs-literal">NULL</span>)&#123;<br>            shortLen++;<br>            tmp = tmp-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 如果A短B长就交换指针</span><br>        <span class="hljs-keyword">if</span>(longLen&lt;shortLen)&#123;<br>            <span class="hljs-built_in">swap</span>(longLen,shortLen);<br>            <span class="hljs-built_in">swap</span>(longOne,shortOne);<br>        &#125;<br>        <span class="hljs-comment">// 让长链表上的指针往后移动, 让两个链表指针位于同一起点</span><br>        <span class="hljs-type">int</span> move = longLen-shortLen;<br>        <span class="hljs-keyword">while</span>(move--&gt;<span class="hljs-number">0</span>)<br>            longOne = longOne-&gt;next;<br>        <span class="hljs-comment">// 定义返回值, 如果没找到符合要求的节点就返回NULL</span><br>        ListNode* rs = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-comment">// 两个指针同步向后移动, 如果找到符合要求的节点就break</span><br>        <span class="hljs-keyword">while</span>(longOne!=<span class="hljs-literal">NULL</span>)&#123;<br>            <span class="hljs-keyword">if</span>(longOne==shortOne)&#123;<br>                rs = longOne;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            longOne = longOne-&gt;next;<br>            shortOne = shortOne-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> rs;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="142-环形链表-ii"><a class="markdownIt-Anchor" href="#142-环形链表-ii"></a> 142. 环形链表 II</h4><p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">力扣传送门</a></p><blockquote><p>统计链表大小肯定是不行的, 永远走不到头<br />如果想存下来所有节点的地址, 然后看看什么时候存到一个重复的地址, 这种方法固然逻辑上讲的通, 但是实际业务中的节点非常多, 那么这种方法必然十分占用空间, 也不行<br />可以用快慢指针, 快指针一次走两格, 慢指针一次走一格, 这样的话, 只要有圈, 那么快指针一定能从后面再绕一圈追上慢指针</p></blockquote><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png" alt="" /></p><blockquote><p>假设从头结点到环形入口节点 的节点数为x, 环形入口节点到 <code>fast</code>指针与<code>slow</code>指针相遇节点 节点数为y, 从相遇节点 再到环形入口节点节点数为 z</p></blockquote><blockquote><p>那么相遇时： <code>slow</code>指针走过的节点数为: <code>x + y</code>， <code>fast</code>指针走过的节点数：<code>x + y + n (y + z)</code>，n为<code>fast</code>指针在环内走了n圈才遇到<code>slow</code>指针， <code>(y+z)</code>为 一圈内节点的个数A。</p></blockquote><blockquote><p>因为<code>fast</code>指针是一步走两个节点，<code>slow</code>指针一步走一个节点， 所以 <code>fast指针走过的节点数 = slow指针走过的节点数 * 2</code>：</p></blockquote><blockquote><p><code>(x + y) * 2 = x + y + n (y + z)</code></p></blockquote><blockquote><p>两边消掉一个<code>(x+y): x + y = n (y + z)</code></p></blockquote><blockquote><p>因为要找环形的入口，那么要求的是x，因为x表示 头结点到 环形入口节点的的距离。</p></blockquote><blockquote><p>所以要求x ，将x单独放在左面：<code>x = n (y + z) - y</code> ,</p></blockquote><blockquote><p>再从<code>n(y+z)</code>中提出一个 <code>(y+z)</code>来，整理公式之后为如下公式：<code>x = (n - 1) (y + z) + z</code> 注意这里n一定是大于等于1的，因为 <code>fast</code>指针至少要多走一圈才能相遇<code>slow</code>指针</p></blockquote><blockquote><p>这个公式说明什么呢？</p></blockquote><blockquote><p>先拿n为1的情况来举例，意味着<code>fast</code>指针在环形里转了一圈之后，就遇到了 <code>slow</code>指针了</p></blockquote><blockquote><p>当 n为1的时候，公式就化解为 <code>x = z</code>，</p></blockquote><blockquote><p>这就意味着，<strong>从头结点出发</strong>一个指针，<strong>从相遇节点也出发</strong>一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点</p></blockquote><blockquote><p>如果n不等于1, 情况也一样, 仍然会相遇, 只不过从相遇节点出发的指针需要走几圈才能碰上另一个指针</p></blockquote><p><img src="https://code-thinking.cdn.bcebos.com/gifs/142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II%EF%BC%88%E6%B1%82%E5%85%A5%E5%8F%A3%EF%BC%89.gif" alt="" /></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * struct ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode *next;</span><br><span class="hljs-comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="hljs-comment"> * &#125;;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">ListNode *<span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>        ListNode* fast = head;<br>        ListNode* slow = head;<br>        <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span> &amp;&amp; fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>            slow = slow-&gt;next;<br>            fast = fast-&gt;next-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast==slow)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(fast==<span class="hljs-literal">NULL</span> || fast-&gt;next==<span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        ListNode* find = head;<br>        <span class="hljs-keyword">while</span>(fast!=find)&#123;<br>            fast = fast-&gt;next;<br>            find = find-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> find;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>数据结构</tag>
      
      <tag>C++</tag>
      
      <tag>力扣刷题</tag>
      
      <tag>Java转C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>加密文章1</title>
    <link href="/2023/07/21/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A01/"/>
    <url>/2023/07/21/%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A01/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0a81fd256f516347da5e3562fb75dbcadb4486fd1bdcb831516e980a8904a7fd">0995c06c86accb8f1a6f2e90f5979125d836c3f9d59f159a6504f95c3587df8f29a3eed40d09444b03a2d8f245a3dbdf761cf0c1f14beb09a3560bffba511b1d954ffef8bbadd062daa87fc3f1f1fbde1a89cee051267cc51acdef318512962294153e09d7ee0cda7215425dea150c5319ad92c72651b18ce7ff092a57e4189a49f1dcadfa3047e3539599423d59b801ef9cc043074312ddffe2e19c90b7f508acbb93d62d6790623a6cef8ca825505425cfb29bf410c4834e06275a99d12321a14c686b81783245d17c1527107bf1658f35d2c3e38d36f2b27f0cdfa87728903808d88756699facfb8ce63c8b19c71f7124bc2c3f5f014a55c6e57ed41063d6d09a161d598773bea92e305212bfc2cdc551e613973d31fad3c393f0a62bdccc6e311ee7a0f905e0b5faf6813f5efd399954894f4de1bef1b76f7d5070ecd132fa99b3806df0456a703ff39d893279126814053f62e5aaed53bdb9242be6d47dbb64424a50001fefe2dc584ebc693949e5cf9cc3ff3d14a10bd866f0972b52ad2c753f6f0efa7c2ee072bde62e52e1919798c5f8be7c1480cb47795742ec318c1cf4bad9431327aa9bf9295d6064b2ede2780f93eae9dc2916c694bb08a9ec8e49758a0d225a0ceae3f9b09cc56def02293b94641f74de3265ce8931c6ecc214c644818ade4e69d38f5da9119e13bdf88dbcae8862ababb8306dbde218f10de592dc37de2565e77ac1ae4130ed1ecd2510f35cdbba9ef7813edf0ada7b5bff494cf9bd85d433e0901c4b1a7a4ab6c8d88d92d6f5eeb9ebf29959c1874e2f2a351bf8445e536e8d03216dc9456ab1b33cd481d6f6d6e0d1e19ac7a72d8485c8d86dabfcfea97c86ef91788875c4de00f45bdf244ee2fcf79d774651ba00cc0f5f2b11aab5311bd83fd22127138ff70940919e217f1f4670d6a68c2451bc39202f4da4d82ed08ef65e29b530e035421b2f38ef030a7f7dad8a0cea9006440d8ba8a584e85a6234889b8e9f8ab51c5506540382b73dfadaeff73c69ee2d16dc24e2af0f79267125e3d8a8fba73f1eb8045c51bc30715ce5f3e4e36e54e88efa4cfd388ec9d5723188ca29bd3ac0901a963cd594a05bcf4a131868c44cdec2274819344501ceb12274c0f9f56fd5afab9f6ea5abbf95ea9304024ff7bce0aaf26a8ea72be7690d60dfc3c960cbbea936cded480613092c20db5dade4316a72016c1ffd2f3620b4ac4069efb0d79e6d192c4e1136be90f2839742170563fd880df7ad8a6288511eea46f7db55ce677c578470096f3f741fca7ba8bc90ed5ffd5b7ae26c7b642d7e1afa11ed3e2634eb0deb8c25d468547e796df25d7cd1185bd5a132762f61baa4a28bbed98979646498df82153123b9d679d14c6f07b1052d7d68ff75fe5fce362a000e756b2dd7e218967050e33ed289d9b5b34896430887574352c9593b1868b0d9c253b9b125c1771b8c02b6257f500dd7c14071867233e9a34f10ce8e7796a4699c16299d6a009ca72b0f95fc635909c2e3ac5018085b3d602926f1b4afa97886bc270fff29e91d7141ba20ec3a0439fb8bacd3836121b0523731c68a3e93105179a763cadbb5fc61a618ba0703acc121dd3200073aab603a30d23aae1ffce1ddfa019ad34cb129c598f6fd217f39effb0643cbb816bd057cf8b4b03c5d8d8389937599de300ec43aa02a2a0bc875bef842d95f7034178c0b92b5c62e34ce7507aff27013f98ff06767b3e1259222615dddc3cb369ae6fe48c3941684e87ef7eadddce9760b054a26c32c030a48aabd9ec2ecc71b39e8c0f73a4004b166018d58ce74ca4a29bc1cf2132b5f380e4eba3af6c3abfdd839d2dc57755098430f07512e0e3de207dde4c9a5d4c45f1c513c6db161e57a1ba3571d6e6db68a84cc1cddc5d2999f89123b6ede64a4a9016ac0d8bf1fe6b90745855302e87a067b8470dca24555a5d31eab705ed6a0e70a162c75c7970204b65513de7e73c5ec8a3fdc291845e67e4c63dc8c35d39d7909c5babb4c86e7d07860c52d883fbd4a288ba9c38464ff3f9422b7995ac2f34f9e72cb5cf4658d7b139c30821f346f434e3584ff9eba9f12006a4aabdf8a132efe1bebf58d3f2bed73ad89eee3d0445d7dae8bcb2b970a3427d32f64718f47cb3dbaaf9674abb57e5b3f970c9397a47fa90c19239dbc59ec0d0dfd5f96e4380151f0d5ed73f5530314acb55ba26db61890687ceb14cd891cc4dc58c510a46179e5e4a592bf6b249470c816fb1410b595b6975d2769012089fde0f4330ae79b206d3f53ad51c334f4a32c2375f63d402fe30c6fcd60a77c3e0a1710638b9df4da5b1f3fc596abd064aa5caea84b3d7380bddd9bd05d634234ea69bef6dbe0c0b54262e81c65372e663591bd4bb9925ea35b5e74ff18c242a50ca8d7a80b46bc3bd3b26d419a612575327127ea06a3bc3b9989c8d0ee77a1fa06740573c426c5bf9c98ac3bfd9710d1568d15ccd06084de981540d7470471b0bc2cdf77fa8746e5678418fadcc255810f0f2cfc90c064b8c06f7e8c5b521de7fff5b16da7fb669b0b74ef6572fcb3871b4a02c90155703c80de45348e1b462af4cd5223da7d62580da277ac14bb8ca5af104fe93b26320d2d5e9fa52b18fbf3b27d60a2c26fda88c5f6f694841063c048443058328fecc938d9e3d4c7f6975b2d7bc8fa990e5be0dfcbae81029f4b9e10e094a74119a116558743c930a62bb89064461f6949e76f0933d40713556665eb70f5f17b4b840db5dd1c7bd9f25342b4a5bc801fc1b41de92c3df9470ca4b57d8daf85d9daa4eb9c7339c99415d0a33d3a6b26235d6cba8f80e3a10f191ffe0adabf0cd69908a921a1acbc431e8ad5220c6d2f534301e4d09035c7e2406ae8289fae1553127a0bd36451d68a8e399326905c8b5067d6e0967562c9fc105584af01e5e9ec9e821b17c73b56366469c72e23013ae000c9590a271d18bb7f4db459f3a43b6e73f20cb6a6860f071620ef63c1d12fd19065543496edc13a007a94a7aa1b094a13d996a1e1cf264aeb52c0d027297842bd980f04e882a292ad0d3ca041804345af17799ed5c8fb18bcf619b3430113cd1d4e0be21582aa32214cf2b48dbf43e0f04d66c543aa2c9130190dfb49f4b6726f78c0e9e7a0b524e2af7d66a3e18d10835250e81fba078af8de4d1a51e6976356148dacb1f28a185c51b0e1b76fb7763bf012b40096dec21f7a85887610c64558653e55971371068af8ad74916ce489ecbd2978a8caf1bb71bdbfd3cc8fab2dfd8f6dfecae54b1002584d170ca2b3d01c8699dbcac1a2cbd2736e007ead5dbb797f0a189bf86ec0fa927d144721adf83c62f138886390600eb0535022751bcfa8b8e15db46b3b45cf093e45627b2a1196ede422d9435eeb920a29b7280f184381b4bfe790970d8ac6668db6ef0fec0d62b0931f3fdbea89dabf024bdc1830f89aae4a54d3fa33bf7db1d98649879ea78e36eb365a3dfd5fdfece9ca109d66b559f51bb6270307c3524eece2d0b85d7f73aa4918eac28ac9099225e1884a8bd1dea3d60577b046ab4e7bae64dc6e7fbfc448ac22081d5f18958764db5de8914e8f20d68907a1460d97a1a9ed2aea4947385dd690798f800162f36a542d04c6128e76a03dbe4b0ceeac2ba2a995d4f2db6343dc2d6dd971125f149c23b26e22d86b33fdc129f7c944d0d65ab171ff5c5f6c0bbf8ebbbc32a2630aed2790fb1ce417a45c91aa6053887e1c5d85925ac2fe13c04665e6a2019a4c07e6503ff8f3f0e89fe4942d70e937fe8739b0c446ce3149026c1b3c2fff4bfaf1e454e815d0d5cce8ebf9fe36478cd975bd8e68cc3804c9e98850b42e474d9f2656765e23c4c872a332bec6753a5fec7a3eb21122d063dba6b104e46fb8a24fb4d3661f96c61e82132ccafaefe32387fbf9c8787aeb5b20a6a170bf0773da01f5cf3cf444e638f54539b4182c9359b70fafd6365c83587d9b7b798f7d2aaa1f4c5abe8a496d6c4e3447ba0575fca9d463ea123bdbd63bc1cf8b911e172221d457634f7c48eef4ade729e6ae761a318d1d8026128a91bbae0448799b77a4c2a7fff35968bfa1436172ef4d9da8f1790cc8460135df585c749546883b84cd500e8ce066839e1d03d6ee85eeb4c2a0f3ab17aef76605b50407e73657a0719f4eb707d3c726334925643ea27b360fefe6ace1205f787fe8329c76ecabbeb2fad336811d3a9add7067d2989901f9c907aab9dca3a37d5103020d2b83815eaea6ea7c5785e926338084d34284cb6c38c4e59c3a1ec2f2bd0d677755f84ebea8a8f5924a813547b1eb4afe5bdd6592de8955dee2f9c2f71475e0cb4e7ca5870a2a84e100feb40541a34546db26e92b405291a3a255d32500cf64bb1d257adf364cc0ba3890da501935b3bffcbcc14cc6c59dbc1374031406b81b8e09d58747cd364689bc8b5185f1718d14bbfc650f7ac0e62b7a64842164a1b877fcf621eccccb654dc0b40e1a19a18a2f737489135157dca47aaf991ba2ffc880a3ddcece1bae157413d827f01a3d4f8d545d0712b59d7e4e4681f113ded62b0cb6ba78d6aa80380e4f42a429ebb328ea1e8d25eea4ba79dd44987e7569aecf37772c6d75df6a8794b9e16f854c0764eac01d8e147736648188efba02a802e7987d00c42b8991d1d509ede881fa6f35a6a3f32b559eae9750d3f59ab45c61bbfd61d1737f3dc8cb8a4eccba81e77a6b536426c01024a3a77cb3839f4e61b3689b48fe4d4f312cd519dbf29e146ffb845a4bfd28360ad4646d6048613d0ba4a3f5a274981023c3a07af264ec36630026f3d3816c8a1704690eeda74b74fb36a4c2f168f535d53b3c4bbed0ce0f14709b53ee8b1061fb461af3225be79dd894a97bbec0c3a508b239c8ef9fd7b7e489d1d6bad3efd0f4576f478ececd8d3eedd954e550d89484af8ddbd691793ae587cfcecb751872f26f07caad0f85ea949acabfca95f11deed789ebd828c393a2b7e4518ca5aa58c2cab1b16c58a77ac521ebd2575b2c4b7adc4c12e173ccecd36e60f040e061f09114e9b4e3833072959560399ec2e64eccfd30254d694a5bf95bd85e87ac46ae7c89414fe54b5274b3ede00eb168cb66383416fcfb9216fcaaac738acb501937e82844fa7ef50cd1551a0ad76b319c8b21471bda9582f496250a8acd6e70482b57356d858757b6ce144c40c526190915d96161d719edcfef3024ae675cb9c266b33a3c5a5da42b6ab9435aa1daefe939a264eb94f26f9154ec666bd324128b2d461cbb0c67e98a4591b32c4e27ce30bc4eb9c0031d1ca7291eabe48b8b3c6993845da11e5a56459a3db71ea574393fc20644e99a8e4d3618dfb623bfa7d91621669e1e316e876d6987db85e915188d0167d404f6671da42a4c9f0230f21cbec848fff25daf358fc7d1f33ba4edc2a426bda56772d70616f5fc4873ede84950733b6f1f78fb01d5cbe3f426a809a137dc9c8d9cb7f6a329c60425a5e15b244017b0924e0f7bb1a82877065e126bc73910cca14930e4ac2e97f0a847bbb22e6f9c6ba3379c55ee0c65ea0865fcd02cd1b018a5877009d1f7f96ecf228dc318c3fb2d7dc80a9c4cc441780d451b35c57f67be3b1c93caa1df18fe0e457cd65ef08d68a215c885197e63d307a97e2c85a00056ec9fa3b6bf2dc9dbdcc082cf1d200c45bcb5c750135a29554e08049940a9f5e67176efa177010fd4fb2f455082938b0c5d7ca25839e920e9bf9f187ce72f8ec326ca3bde76ed7b2249a8ed0b0388120605490af0f657556d3276af600d31908ebeaa9bb4d88159b83284b7994684bf248774cafa3155503f6b29f8c41cd78917851be0fd0e78e3adcc503e3888e6b7705cd33b93f915a6209652b7ed29bba69068c5732b2d394ce93723381439c1c7523f074c7e1dc8d4c896b7a909d742a30a083d26298e5102128c7308e2d922640da24be038b592c53cd57ab452ea391fcab632f4ba516e1aafc7d8af936915543e66b561278ed3fd434d1f904497a31b50ea2285bdeb557c1af46dd64adecf13257614aea4966dbe205c22d2f59eb361e90eac241d842863e7287f950ef3d41e7e8d349a082cb5dcf8d56b3a3e6f5345b2af2f8844e0e2d4e0ee160845b9a6b9a4176f31c26c262d5a2292c3d544eee4a0495e25bed80aaa7a2a7391e35018787786ea0247a7836802e257e05c99d705045fcedd529046a30d7be2dc2e8caadeb8e9aaff197b278225857f50cd2436e6e482b543238fd19b284db9bae5768c17ac00b714f28ca1413529f5fa729a9a3d9045f4de90be7cb242f077a75f5400863fc0e91e8cade34cd798a021ae160e335be75327231e6a9d5a7a3bc2908f21edc8d28c076af997effa77706921eb6d9844da045e89b81df5b4a7efefdc806418801e51e79caeb2eb43f5c1e06349ea95db3f0c80b86adfdd7b07ff398011364e479cbcf18772683ce15690a73bfc878965d5beb62c3f89ff4bb05a5e069a327222cce497461f62536ac138a729f6d32a01df9f0e25a2ab6a2de9ebc2cf5c45786bea8215ac8687618c53f61cad10f07d5d910c1eae5fb21e4ab35d47b28bd8554ce270ae613686e28b4fb8f821e572b091c20ceb931ad203af47d43efc010ba3da691e33a83a8c43a6e786eee4b44d0486b78b0f32df564bf1d4ef966020d95a7902317c0b166943173543ac1aae5d505ecd586f0619b12c3f09eeb8b4a62b38918682fb891c1518adf047025d784ac3f22df3221425834a380828fb248139308ccdbd8a213540106b956e98294a998abdd97ed0c3d8a1418c5cf429805d39dd320405d28aec83454532f70da95b6427720ad441fe9d10ea9d5d21ef9e499e19424ed9f8158c63356c879ebc45f6c494c07897c42518d607b80284a2ffc4aac66af4cdf9b3fd573299f954e9285b8e2c8843223b867c46fdfe2815b889de764221b3859ef6905c5f528519653328cd2bdd4da9c3078285f422bf6d6a5829aeac40877975d81f910d54c27c0512c45666d00d316a13f713b9c3e6305b047bad81a6abebadd51a64b9a7b2a8a00718d1e09a39a9a28d847feda6c9d733d87286e6c934547646186783431750c4e53cdef431443fab607fb61b71c506feec887be905c8b0fe5e94a849f68d09ae69f51a51ea6f167d5c734765ec87a10793a5095039a3d47423fbcb688de55045d9929df64f65ce22b28bab069db44b7423f4a8a267df96a5dbc24c12e35b07db5d8ef6412cc2ca8a4cc22cf9ba5485b783ee840332e8e99f81cecb146d4cd5d657533c9830a58c7ee555f2551e8cfad46580cd995c9ff66a7e91b7c1f2a2e02db371231b39cf26e6245679ee45914f95b673b91f8f9d82a36f2240a0fbe0414b496bf636144f1aece6f854fa253bd06e732e09600fe48a5f6658e5590ef0b8661a96e61a2fd5ed9952450d17cb6516d5875ebc6f1531a18b42f39967505640031545d93e0464e3e74ecb886d02440da5d60eeeb39c620e3922fc7586ea5de93db3a4ae9b3bb09a95ad6adfb7fc2cfc1689fc6a11c2f189a526751d11c763f0375860fe7847d22a24fe1dd777e6c5575089a2773e91717ca7f465d916d504a8bcc8878659a1e582c0169584c04b0c20b0621f83f191170e21e59453c599949279068a37a1b6e86f4838d89af9c18da6b8837c942569a032a791a6e5c6c8c5d18fcc736c3c0f34b7c9d36c2d5797acb1c967d203b29b0305b564abcb1ad845d3b6364964f4cbb0ae0c7aeb01fe6cb8d4e77992b722358a38fe206061cc06c01bbeb09ac762387add2aab7ed0cc11e478951643c8d5c0fa724093c75937ab86c38dd0c234ccf0663143e35c7792c450a9a9b54507ef5d6df4152a157bd6b2ad699728c1c466c941b776f129079ffa45af7f9f1dcb3eb6b57dfa3a4d5bf9b8e15006ef1a46c4639a4d3c87237629da7553f8dec295db87900e176fa01186d03501e7e02ccd931cd27a3c48e82c5d8e969a3d7d1f2dfaf7f14744fcd9feebfea60b1b5b04964325fc6dd1bc600f6c6d82ed0bcd5da0ce4cd5d23ff52bdf9a801a1848179b8953d54b017a564f854931acd5402b4ac85157503eba96f6ac2aecfc2274c690b81c626179c06d95974743d07f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>加密</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一篇文章学会Markdown</title>
    <link href="/2023/06/22/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9AMarkdown/"/>
    <url>/2023/06/22/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%AD%A6%E4%BC%9AMarkdown/</url>
    
    <content type="html"><![CDATA[<h3 id="本文通过先展示效果再展示代码帮助大家快速学会markdown"><a class="markdownIt-Anchor" href="#本文通过先展示效果再展示代码帮助大家快速学会markdown"></a> 本文通过先展示效果再展示代码帮助大家快速学会Markdown</h3><hr /><h3 id="六级标题"><a class="markdownIt-Anchor" href="#六级标题"></a> 六级标题</h3><h1 id="一级"><a class="markdownIt-Anchor" href="#一级"></a> 一级</h1><h2 id="二级"><a class="markdownIt-Anchor" href="#二级"></a> 二级</h2><h3 id="三级"><a class="markdownIt-Anchor" href="#三级"></a> 三级</h3><h4 id="四级"><a class="markdownIt-Anchor" href="#四级"></a> 四级</h4><h5 id="五级"><a class="markdownIt-Anchor" href="#五级"></a> 五级</h5><h6 id="六级"><a class="markdownIt-Anchor" href="#六级"></a> 六级</h6><h2 id="-code0-"><a class="markdownIt-Anchor" href="#-code0-"></a> <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="hljs-section"># 一级</span><br><span class="hljs-section">## 二级</span><br><span class="hljs-section">### 三级</span><br><span class="hljs-section">#### 四级</span><br><span class="hljs-section">##### 五级</span><br><span class="hljs-section">###### 六级</span><br></code></pre></td></tr></table></figure></h2><h3 id="区块"><a class="markdownIt-Anchor" href="#区块"></a> 区块</h3><blockquote><p>这是一个区块</p><blockquote><p>区块也可嵌套</p></blockquote></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="hljs-quote">&gt; 这是一个区块</span><br>&gt;&gt; 区块也可嵌套<br></code></pre></td></tr></table></figure><hr /><h3 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h3><p>有序列表：（数字点后面添加一个空格）</p><ol><li>打开冰箱门</li><li>把大象塞进去</li><li>关上冰箱门</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="hljs-bullet">1.</span> 打开冰箱门<br><span class="hljs-bullet">2.</span> 把大象塞进去<br><span class="hljs-bullet">3.</span> 关上冰箱门<br></code></pre></td></tr></table></figure><p>无序列表：（* - +号都行，这些标记后面要添加一个空格）</p><ul><li>数学课</li><li>英语课</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="hljs-bullet">-</span> 数学课<br><span class="hljs-bullet">-</span> 英语课<br></code></pre></td></tr></table></figure><p>嵌套列表：</p><ol><li>第一个需求<ul><li>子需求</li><li>子需求</li></ul></li><li>第二个需求<ol><li>第一步</li><li>第二步</li><li>第三步</li></ol></li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="hljs-bullet">1.</span> 第一个需求<br><span class="hljs-bullet">    -</span> 子需求<br><span class="hljs-bullet">    -</span> 子需求<br><span class="hljs-bullet">2.</span> 第二个需求<br><span class="hljs-bullet">    1.</span> 第一步<br><span class="hljs-bullet">    2.</span> 第二步<br><span class="hljs-bullet">    3.</span> 第三步<br></code></pre></td></tr></table></figure><hr /><h3 id="段落与字体"><a class="markdownIt-Anchor" href="#段落与字体"></a> 段落与字体</h3><p>直接换行后为同一段内换行，两个空格后换行或者在直接编辑器中空一行表示下一段：</p><p>第一段第一行<br />第一段第二行</p><p>第二段</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">第一段第一行<br>第一段第二行<br><br>第二段<br></code></pre></td></tr></table></figure><p><em>斜体文字</em></p><p><strong>粗体文字</strong></p><p><em><strong>粗斜体文字</strong></em></p><p><s>删除线文字</s></p><p><u>下划线文字</u></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="hljs-emphasis">*斜体文字*</span>  <br><br><span class="hljs-strong">**粗体文字**</span>  <br><br><span class="hljs-strong">**<span class="hljs-emphasis">*粗斜体文字*</span>**</span>  <br><br>~~删除线文字~~  <br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">u</span>&gt;</span></span>下划线文字<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">u</span>&gt;</span></span>  <br></code></pre></td></tr></table></figure><p>脚注：（点击脚注会自动跳转到文章末尾释意）<br />今天我们学习鲁迅<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="鲁迅，原名周树人，著名民主战士。"><a href="https://www.baidu.com/">1</a></span></a></sup>文章:《论他妈的》</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">今天我们学习鲁迅<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="鲁迅，原名周树人，著名民主战士。">[1]</span></a></sup>文章:《论他妈的》<br>[<span class="hljs-symbol">^1</span>]: <span class="hljs-link">鲁迅，原名周树人，著名民主战士。 </span><br></code></pre></td></tr></table></figure><p>分割线：<br />三个以上的*号，或者-号，可参考本文其他地方的分割线不再单独展示。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">---<br><span class="hljs-strong">**<span class="hljs-emphasis">*</span></span><br></code></pre></td></tr></table></figure><p>下标：<br />Fe<sub>3</sub>O<sub>4</sub></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">Fe~3~O~4~<br></code></pre></td></tr></table></figure><p>上标：<br />x<sup>2</sup></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">x^2^<br></code></pre></td></tr></table></figure><p>高亮文字：<br /><mark>这是一段高亮文字</mark></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">==这是一段高亮文字==<br></code></pre></td></tr></table></figure><hr /><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3><p>两对 “```” 包括（反引号在键盘左上角，横版数字键的左端），可以指定语言，也可以不指定，指定后的语言会根据不同语言的关键词做颜色区分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>```C++<br />int main(){<br />print(“Hello World!”);<br />return 0;<br />}<br />````<br />(此处代码区为显示效果，效果的实现代码如上)</p><p>直接使用制表符tab键，或四个空格，也可以形成代码区</p><p>如果是段落内代码，不单独占用整行区域，可以使用一对反引号括起来，就像这样<code>print()</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="hljs-code">`print()`</span><br></code></pre></td></tr></table></figure><hr /><h3 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h3><p>方括号写站点名，圆括号写链接<br /><a href="https://www.baidu.com/">百度</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">[<span class="hljs-string">百度</span>](<span class="hljs-link">https://www.baidu.com/</span>)<br></code></pre></td></tr></table></figure><p>尖括号可以展示一个可点击的链接<br /><a href="https://www.baidu.com/">https://www.baidu.com/</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="language-xml">&lt;https://www.baidu.com/&gt;</span><br></code></pre></td></tr></table></figure><p>如果链接需要多次出现，可以将链接赋值一个变量，随用随取：<br /><a href="https://www.baidu.com/">百度</a></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">[<span class="hljs-string">百度</span>][<span class="hljs-symbol">1</span>]<br><br>[<span class="hljs-symbol">1</span>]: <span class="hljs-link">https://www.baidu.com/</span><br></code></pre></td></tr></table></figure><hr /><h3 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h3><p>使用竖线 | 区分不同列；<br />冒号的不同位置区分对齐方式（表格中添加123以防止看不出对齐方式）；<br />短横线至少一个；<br />左右端竖线可以省略。</p><table><thead><tr><th style="text-align:left">第一列</th><th style="text-align:center">第二列</th><th style="text-align:right">第三列</th></tr></thead><tbody><tr><td style="text-align:left">左对齐123</td><td style="text-align:center">居中</td><td style="text-align:right">右对齐123</td></tr></tbody></table><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">|第一列|第二列|第三列|<br>|:---|:---:|---:|<br>|左对齐123|居中|右对齐123|<br></code></pre></td></tr></table></figure><hr /><h3 id="图片"><a class="markdownIt-Anchor" href="#图片"></a> 图片</h3><p>先写叹号“！”；<br />方括号写图像名字；<br />圆括号写地址，可以是相对地址，也可以是绝对地址；<br />双引号内的文字可以在鼠标悬浮图片上时显示。<br /><img src="https://img.gejiba.com/images/18fe10b3ff7a148d67b7b78a2451bc5d.jpg" alt="头像" /></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">![<span class="hljs-string">头像</span>](<span class="hljs-link">logo.jpg &quot;头像logo&quot;</span>)<br></code></pre></td></tr></table></figure><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用HTML中普通的 img 标签<br /><img src = "https://img.gejiba.com/images/18fe10b3ff7a148d67b7b78a2451bc5d.jpg" width = "200px"></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span> = <span class="hljs-string">&quot;logo.jpg&quot;</span> <span class="hljs-attr">width</span> = <span class="hljs-string">&quot;200px&quot;</span>&gt;</span></span><br></code></pre></td></tr></table></figure><hr /><h3 id="数学公式"><a class="markdownIt-Anchor" href="#数学公式"></a> 数学公式</h3><p>行内数学公式：$ \sum_{n=1}^{100} n^ 2$</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">$ \sum<span class="hljs-emphasis">_&#123;n=1&#125;^&#123;100&#125; n^2 $</span><br></code></pre></td></tr></table></figure><p>单独占据整行：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></span></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Markdown">$$<br>E=mc^2<br>$$<br>//这样排版美观，也可以写在一行内<br></code></pre></td></tr></table></figure><hr /><h3 id="特殊需求"><a class="markdownIt-Anchor" href="#特殊需求"></a> 特殊需求</h3><p>如果你还有其他特殊需求，可以自行搜索使用HTML标签实现，Markdown中支持一些HTML标签，例如上文提到的<code>&lt;u&gt;下划线文字&lt;/u&gt;</code>和<code>&lt;img src = &quot;logo.jpg&quot; width = &quot;200px&quot;&gt;</code>本质为HTML标签</p><hr /><h3 id="其他事项"><a class="markdownIt-Anchor" href="#其他事项"></a> 其他事项</h3><p>本文为了使小白快速上手语言较为通俗，如“段内显示”和“单独占据整行”，实际为HTML中的“行内元素”和“块级元素”，专业人士不喜勿喷。</p><p>也许你已经注意到了，本文同样采用Markdown进行编写，Markdown在写笔记，发表博客，排版方面有巨大优势。</p><p>公众号&quot;一只达瓦里式&quot;回复0720可获取此页面的Markdown格式文件。</p><h3 id="注释"><a class="markdownIt-Anchor" href="#注释"></a> 注释:</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>鲁迅，原名周树人，著名民主战士。<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法(粗略总结,Java实现)</title>
    <link href="/2023/06/22/%E6%8E%92%E5%BA%8F(%E7%B2%97%E7%95%A5%E6%80%BB%E7%BB%93)/"/>
    <url>/2023/06/22/%E6%8E%92%E5%BA%8F(%E7%B2%97%E7%95%A5%E6%80%BB%E7%BB%93)/</url>
    
    <content type="html"><![CDATA[<p><strong>稳定性</strong>：如果相同元素的前后相对位置不变，就说这种排序算法是稳定的</p><h4 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h4><ol><li><strong>直接插入排序算法</strong></li></ol><blockquote><p>序列分为两部分，一部分有序，一部分无序，每一趟都从无序的中挑一个插入到有序的序列中，共执行n-1趟<br />每趟拿到的数一点一点交换往前移动，这样的话遇到相同的数就不移动，算法稳定</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>; i&lt;keys.length; i++)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> key[i], j;<br>    <span class="hljs-keyword">for</span>(j=i-<span class="hljs-number">1</span>; j&gt;<span class="hljs-number">0</span> &amp;&amp; x&lt;key[j]; j--)<br>        key[j+<span class="hljs-number">1</span>] = keys[j];<span class="hljs-comment">//j元素后移</span><br>    keys[j+<span class="hljs-number">1</span>] = x;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>正序序列，时间复杂度O(n)；反序序列，时间复杂度O(n<sup>2</sup>)<br />随机排序，等概率情况下为O(n<sup>2</sup>)</p></blockquote><ul><li><p><strong>改进</strong> 增加哨兵位而不是用通过j&gt;0来比较，比较操作在汇编层面更耗时间</p></li><li><p><strong>改进</strong> 可以通过二分查找查看有序的那一部分中应该插入到哪儿</p></li><li><p><strong>稳定性</strong> 稳定</p></li><li><p><strong>时间复杂度</strong> 最好正序O(n)，最坏倒序O(n<sup>2</sup>)</p></li><li><p><strong>空间复杂度</strong>O(1)</p></li></ul><h4 id="希尔排序缩小增量排序"><a class="markdownIt-Anchor" href="#希尔排序缩小增量排序"></a> 希尔排序(缩小增量排序)</h4><blockquote><p><strong>分组</strong>，增量delta=4，那就每隔4个位一组</p></blockquote><table><thead><tr><th style="text-align:center">38</th><th style="text-align:center">55</th><th style="text-align:center">65</th><th style="text-align:center">97</th><th style="text-align:center">27</th><th style="text-align:center">76</th><th style="text-align:center">27*</th><th style="text-align:center">13</th><th style="text-align:center">19</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">i</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">i+4</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">i+4+4</td></tr></tbody></table><blockquote><p>0号和4号和8号比，不符合顺序就交换，1号和5号比较<br />每一组都分别整理好组内的顺序</p></blockquote><blockquote><p>下一次delta=2，整理好<br />下一次delta=1，整理好<br />排序完成</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> delta=key.length/<span class="hljs-number">2</span>; delta&gt;<span class="hljs-number">0</span>; delta/=<span class="hljs-number">2</span>)&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=delta; i&lt;key.length; i++)&#123;<span class="hljs-comment">//这里结束叫“一趟”，一趟过后的特点是，分组有序</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> key[i];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i-delta; j&gt;=<span class="hljs-number">0</span> &amp;&amp; x&lt;key[j]; j-=delta)<br>            key[j+delta] = key[j];<span class="hljs-comment">//后移</span><br>        key[j+delta] = x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>凭啥这种方式能排序更快？<br />这种排序每个元素需要归位的话，他每一次能移动的更多，腿更长，变量能够“大跨步地向这更加正确的方向运动”</p></blockquote><ul><li><strong>稳定性</strong> 算法不稳定， 跨步交换的过程可能会交换两个相同元素的相对位置</li><li><strong>时间复杂度</strong> 比较复杂</li><li><strong>空间复杂度</strong>O(1)</li></ul><h4 id="冒泡排序"><a class="markdownIt-Anchor" href="#冒泡排序"></a> 冒泡排序</h4><blockquote><p>从前到后，相邻两个比较，不符合顺序就交换，每一趟能归位一个</p></blockquote><blockquote><p>和插入排序的区别<br />插入排序是依次<strong>移动</strong>变量，冒泡是依次<strong>交换</strong>变量<br />插入的前面是排好序的序列，插入的后面是排好序的序列</p></blockquote><ul><li><p><strong>改进</strong> 如果有一趟没有交换，那么就停止算法，序列已经满足顺序，使用一个布尔型变量标记这一趟有没有交换</p></li><li><p><strong>稳定性</strong> 如果相等不交换，那么相对位置不变</p></li><li><p><strong>时间复杂度</strong> 最好O(n)，最坏O(n<sup>2</sup>)</p></li><li><p><strong>空间复杂度</strong>O(1)</p></li></ul><h4 id="快速排序重点"><a class="markdownIt-Anchor" href="#快速排序重点"></a> 快速排序（重点）</h4><blockquote><p>设置基准值，大于基准值的和小于基准值的各分一组，这两组分别找基准值，分组……<br />当一组只有一个就是排序成功</p></blockquote><blockquote><p>怎么分组？<br />通过两个指针前后相对运动来分两组，前后顺序不对就交换</p></blockquote><blockquote><p>切记前后两个指针，一趟过后判断序列的时候，两个指针分别走i先j后，所得序列和原序列完全无关<br /><img src="2022-11-20-22-19-50.png" alt="" /></p></blockquote><ul><li><strong>稳定性</strong> 不稳定，有跨越，可能导致跳过相同的值</li><li><strong>时间复杂度</strong> 最好每一次都分成长度相近的两个子序列O(nlog<sub>2</sub>n)，最坏每一趟都分成差异很大的两个子序列O(n<sup>2</sup>)相当于普通排序</li><li><strong>空间复杂度</strong> O(1)</li></ul><h4 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h4><blockquote><p>每一趟<strong>选择</strong>未被排序的序列中最大的元素放到最后，每趟归位一个<br />n-1趟</p></blockquote><ul><li><strong>稳定性</strong> 不稳定，会跳跃</li><li><strong>时间复杂度</strong> O(n<sup>2</sup>)</li><li><strong>空间复杂度</strong>O(1)</li></ul><h4 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h4><blockquote><p>第一次构建堆麻烦一些，但是构建好之后，取出堆首元素，堆尾元素放到堆首，然后往下滑(不止滑一步)，初次构建时候建议也搞成滑动操作，而不是简单的交换操作，每一个结点都往下滑动</p></blockquote><blockquote><p>完全二叉树，用数组模拟，索引从0开始的话，每一个结点index*2+1就是左孩子结点，array.length/2-1就是第一个非叶子结点</p></blockquote><ul><li><strong>稳定性</strong> 不稳定，会跳跃</li><li><strong>时间复杂度</strong> O(nlog<sub>2</sub>n)</li><li><strong>空间复杂度</strong>O(1)</li></ul><h4 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h4><blockquote><p>基础操作是合并两个已经排序的序列(双指针)<br />两两一组，排序，每两个组合并…，最后只剩下一个组</p></blockquote><ul><li><strong>时间复杂度</strong>一共排序合并log<sub>2</sub>n次，每一次操作次数都是n，时间复杂度为O(nlog<sub>2</sub>n)</li></ul><h4 id="做题总结"><a class="markdownIt-Anchor" href="#做题总结"></a> 做题总结</h4><ul><li><strong>选择排序、冒泡排序、堆排序</strong>，每一趟都能够归位一个，<strong>插入排序</strong>不能归位，只能是一个有序的序列，最小的和最大的都可能开没出现。</li><li>排序趟数和原始排序有关：</li><li><ul><li>插入排序(要通过反复比较选择插入位置)</li></ul></li><li><ul><li>冒泡排序(一次过后没有交换就说明排好了)</li></ul></li><li><ul><li>快速排序(要是很有序的话，每一次全部序列都在一边，没法分成两半)</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java网络编程</title>
    <link href="/2023/06/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/06/22/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="url类"><a class="markdownIt-Anchor" href="#url类"></a> URL类</h3><ol><li>构造方法</li></ol><blockquote><p>直接输入完整地址<br />协议+域名+资源地址</p></blockquote><ol start="2"><li>获取输入<code>url.openStream()</code>返回一个输入流，尽量放到另一个线程</li></ol><hr /><h3 id="套接字"><a class="markdownIt-Anchor" href="#套接字"></a> 套接字</h3><table><thead><tr><th style="text-align:center">-</th><th style="text-align:center">客户端Socket</th><th style="text-align:center">服务器端Socket</th></tr></thead><tbody><tr><td style="text-align:center">-</td><td style="text-align:center">输入流<code>getInputString()</code></td><td style="text-align:center">输出流<code>getOutputString()</code></td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">输出流<code>getOutputString()</code></td><td style="text-align:center">输入流<code>getInputString()</code></td></tr><tr><td style="text-align:center">构造</td><td style="text-align:center">服务器地址+端口<code>new Socket(String,int)</code></td><td style="text-align:center">ServerSocket对象用来注册端口号<code>new ServerSocket(int)</code> 使用ServerSocket创造Socket对象<code>serverSocket.accept()</code></td></tr><tr><td style="text-align:center">构造解读</td><td style="text-align:center">用地址和端口号构造就会向服务器端发送申请，对方相应端口有程序监听的话就会被接收</td><td style="text-align:center">只要有客户端希望链接就都会被端口监听的程序接收到</td></tr></tbody></table><ul><li><strong>注意</strong> 尽量把输入流读取信息<code>in.readUTF()</code>放在另一个线程中，防止<strong>线程阻塞</strong></li><li>获取到的底层流可以用来<strong>构造数据流</strong>，更加方便读写</li><li>数据流使用方法<code>readUTF()</code>读可以方便一些，也可以构造String对象的时候指定<code>&quot;utf-8&quot;</code></li><li>服务器端先启动，等待客户端请求，服务器端<code>accept()</code>方法也会<strong>阻塞线程</strong></li></ul><h5 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h5><ul><li>端口为0~65535，其中前1024个被占用0~1023</li><li>InetAddress类</li><li><ul><li>用静态方法构造<code>InetAddress.getByName(String s)</code></li></ul></li><li><ul><li>传入域名，toString返回<code>域名/IP</code></li></ul></li><li><ul><li>传入IP，toString返回<code>域名/IP</code>或者<code>/IP</code>，因为IP有多个域名的时候不确定用户希望返回哪一个</li></ul></li><li>客户端多线程使用Thread，这样每一个申请访问的都可以开辟一个线程，且不会互相影响，如果都使用一个Runnable来创建的话会互相影响</li></ul><h3 id="udp数据报"><a class="markdownIt-Anchor" href="#udp数据报"></a> UDP数据报</h3><blockquote><p>UDP数据报传输更快，但不一定保证能够到达目的地主机，也不能数据保证到达目的地的顺序和发出顺序相同，是一种不可靠的协议，用于能忍受微小错误需要更快传输信息的场景</p></blockquote><ul><li><p><strong>发送端</strong></p><ol><li><strong>打包数据</strong></li></ol><ul><li><code>DatagramPacket(byte data[], int length, InetAddress address, int port)</code></li><li>设置偏移量的字节数组<code>DatagramPacket(byte data[], int offset, int length, InetAddress address, int port)</code></li></ul><ol start="2"><li><strong>发送数据包</strong></li></ol><ul><li>无参数构造方法<code>DatagramSocket mail_out = new DatagramSocket()</code></li><li>发送数据包<code>mail_out.send(data_pack)</code></li></ul></li><li><p><strong>接收端</strong></p><ol><li><strong>注册接收端口</strong></li></ol><ul><li><code>DatagramSocket mail_in = new DataSocket(int port)</code></li></ul><ol start="2"><li><strong>接收数据包</strong></li></ol><ul><li><code>DatagramPacket pack = new DatagramPacket(byte data[], int length)</code></li><li><code>mail_in.receive(pack)</code></li></ul></li></ul><p><strong>注意事项</strong></p><ul><li><code>receive()</code>会阻塞线程</li><li>数据包的数据长度最好不要超过8192KB(8MB)</li><li>数据包类的常用方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">getPort()<span class="hljs-comment">//获取发出数据包的远程主机的端口</span><br>getLength()<span class="hljs-comment">//获取数据包的字节长度</span><br>getAddress()<span class="hljs-comment">//获取发出数据包的主机地址</span><br></code></pre></td></tr></table></figure><hr /><h3 id="广播数据报"><a class="markdownIt-Anchor" href="#广播数据报"></a> 广播数据报</h3><blockquote><p>DatagramSocket只允许数据报发送给指定的目标地址，而MulticastSocket可以将数据报以广播方式发送到数量不等的多个客户端。<br />IP协议为多点广播提供了这批特殊的IP地址，这些IP地址的范围是<br /><strong>224.0.0.0~239.255.255.255</strong></p></blockquote><p>关键类：组播套接字类MulticastSocket<br />MulticastSocket socket</p><table><thead><tr><th style="text-align:center">代码</th><th style="text-align:center">目的</th></tr></thead><tbody><tr><td style="text-align:center"><code>int port = 5858</code></td><td style="text-align:center">int型端口</td></tr><tr><td style="text-align:center"><code>group = InetAddress.getByName(&quot;239.255.8.0&quot;)</code></td><td style="text-align:center">创建group</td></tr><tr><td style="text-align:center"><code>new MulticastSocket(port)</code></td><td style="text-align:center">创建组播套接字实例，设置广播端口</td></tr><tr><td style="text-align:center"><code>socket.setTimeToLive(1)</code></td><td style="text-align:center">设置广播范围为只在本地网络</td></tr><tr><td style="text-align:center"><code>NetworkInterface.getByInetAddress(group)</code></td><td style="text-align:center">构造NetworkInterface实例</td></tr><tr><td style="text-align:center"><code>new InetSocketAddress(group,port)</code></td><td style="text-align:center">构造InetSocketAddress实例</td></tr><tr><td style="text-align:center"><code>socket.joinGroup(socketAddress,networkInterface)</code></td><td style="text-align:center">加入group</td></tr><tr><td style="text-align:center"><code>socket.send(packet)</code></td><td style="text-align:center">发送数据包</td></tr><tr><td style="text-align:center"><code>socket.receive(packet)</code></td><td style="text-align:center">接收数据报包</td></tr></tbody></table><p><img src="https://img.gejiba.com/images/57cb5b035d22ee0563784757333481c1.png" alt="" /></p><p>代码如下，感兴趣的同学课后自取<br /><strong>广播端</strong><br /><strong>BroadCast.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BroadCast</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;国庆放假时间是9月30日&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">5858</span>;<br>    <span class="hljs-type">InetAddress</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">MulticastSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    BroadCast()&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            group = InetAddress.getByName(<span class="hljs-string">&quot;239.255.8.0&quot;</span>);<br>            socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulticastSocket</span>(port);<br>            socket.setTimeToLive(<span class="hljs-number">1</span>);<br>            <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">socketAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(group,port);<br>            <span class="hljs-type">NetworkInterface</span> <span class="hljs-variable">networkInterface</span> <span class="hljs-operator">=</span> NetworkInterface.getByInetAddress(group);<br>            socket.joinGroup(socketAddress,networkInterface);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Error:&quot;</span>+e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">play</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-type">byte</span> data[] = s.getBytes();<br>                packet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(data, data.length, group, port);<br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));<br>                socket.send(packet);<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                System.out.println(<span class="hljs-string">&quot;Error:&quot;</span>+e);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">BroadCast</span>().play();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接收端</strong><br /><strong>Receiver.java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.net.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">5858</span>;<br>        <span class="hljs-type">InetAddress</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">MulticastSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            group = InetAddress.getByName(<span class="hljs-string">&quot;239.255.8.0&quot;</span>);<br>            socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulticastSocket</span>(port);<br>            <span class="hljs-type">InetSocketAddress</span> <span class="hljs-variable">socketAddress</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(group,port);<br>            <span class="hljs-type">NetworkInterface</span> <span class="hljs-variable">networkInterface</span> <span class="hljs-operator">=</span> NetworkInterface.getByInetAddress(group);<br>            socket.joinGroup(socketAddress,networkInterface);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e)&#123;&#125;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">byte</span> data[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8192</span>];<br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            packet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(data, data.length, group, port);<br>            <span class="hljs-keyword">try</span> &#123;<br>                socket.receive(packet);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(packet.getData(), <span class="hljs-number">0</span>, packet.getLength());<br>                System.out.println(<span class="hljs-string">&quot;接收的内容：\n&quot;</span>+message);<br>            &#125;<br>            <span class="hljs-keyword">catch</span> (Exception e)&#123;&#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>双向链表(华强买瓜)</title>
    <link href="/2023/06/21/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8(%E5%8D%8E%E5%BC%BA%E4%B9%B0%E7%93%9C)/"/>
    <url>/2023/06/21/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8(%E5%8D%8E%E5%BC%BA%E4%B9%B0%E7%93%9C)/</url>
    
    <content type="html"><![CDATA[<h3 id="情景"><a class="markdownIt-Anchor" href="#情景"></a> 情景</h3><hr /><p>有一个人前来<s>找茬</s>买瓜<br /><img src="https://img.gejiba.com/images/40c96daa2a0963cd49d221eec9e2bc63.jpg" alt="" /></p><p>不是，我们今天是瓜摊老板</p><p><img src="https://img.gejiba.com/images/643c4d9104b1c8e5dd8bcc4086f04e96.jpg" alt="" /></p><p>用双向链表来存储整个瓜摊</p><h3 id="创建节点"><a class="markdownIt-Anchor" href="#创建节点"></a> 创建节点</h3><p>首先，我们需要创建节点，这次摆瓜摊，节点就是每一个西瓜</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watermelon</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> location;<br>    <span class="hljs-keyword">public</span> Ripe ripe;<br>    <span class="hljs-keyword">public</span> Watermelon pre;<br>    <span class="hljs-keyword">public</span> Watermelon next;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Watermelon</span><span class="hljs-params">(<span class="hljs-type">int</span> location, String isRipe)</span> &#123;<br>        <span class="hljs-built_in">this</span>.location = location;<br>        <span class="hljs-built_in">this</span>.ripe = Ripe.valueOf(isRipe);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Watermelon&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;location=&quot;</span> + location +<br>                <span class="hljs-string">&quot;, ripe=&quot;</span> + ripe +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重写toString方法方便后续输出西瓜信息<br />location是西瓜在瓜摊上占的位置，ripe是枚举类，只能有三种对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Ripe</span>&#123;<br>    熟瓜,<br>    生瓜蛋子,<br>    头结点无瓜;<br>&#125;<br></code></pre></td></tr></table></figure><p>读者不熟悉枚举类的话可以直接用布尔型变量来表示，true表示熟瓜，false表示生瓜，头结点存一个空值null就行</p><h3 id="现在我们正式开始写瓜摊链表"><a class="markdownIt-Anchor" href="#现在我们正式开始写瓜摊链表"></a> 现在我们正式开始写瓜摊(链表)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Stall</span>&#123;<br>    <span class="hljs-comment">/*增：摆西瓜</span><br><span class="hljs-comment">    * 插入：按编号插入</span><br><span class="hljs-comment">    * 删：卖西瓜</span><br><span class="hljs-comment">    * 改：偷换一个西瓜</span><br><span class="hljs-comment">    * 查：查看成熟程度</span><br><span class="hljs-comment">    * */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们的通过实际情况来练习双向链表增删改查</p><p>定义好头结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">Watermelon</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;头结点无瓜&quot;</span>);<br></code></pre></td></tr></table></figure><hr /><p>在结尾位置添加一个西瓜，也是通过遍历来实现，遍历到最后一个位置，再添加新的瓜，新的瓜的pre指向最后一个瓜，最后一个瓜的next指向新的瓜</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(Watermelon newWatermelon)</span>&#123;<br>    <span class="hljs-type">Watermelon</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span> (temp.next == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">break</span>;<br>        temp = temp.next;<br>    &#125;<br>    newWatermelon.pre = temp;<br>    temp.next = newWatermelon;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>在中间空位置插入瓜</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addByOrder</span><span class="hljs-params">(Watermelon newWatermelon)</span>&#123;<br>    <span class="hljs-type">Watermelon</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ifExist</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span> (temp.location == newWatermelon.location)<span class="hljs-comment">//这个位置已经有瓜占了</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (temp.location &gt; newWatermelon.location)&#123;<span class="hljs-comment">//找到了合适位置的后一个</span><br>            ifExist = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        temp = temp.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ifExist)&#123;<br>        newWatermelon.pre = temp.pre;<br>        temp.pre.next = newWatermelon;<br>        temp.pre = newWatermelon;<br>        newWatermelon.next = temp;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;这个位置已经有瓜啦&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>一眼看出是个不懂瓜的人或者懂瓜的人，随机应变改变显眼位置的瓜</p><p><img src="https://img.gejiba.com/images/7ddc434aa7b800e22e869c4f28d10ddc.jpg" alt="" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exchange</span> <span class="hljs-params">(Watermelon newWatermelon)</span>&#123;<br>    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;今天的瓜已经卖完了&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">Watermelon</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ifExist</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//标记一下，该位置有没有瓜，有瓜再换，没瓜也不用换</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (temp.location == newWatermelon.location)&#123;<br>            ifExist = <span class="hljs-literal">true</span>;<span class="hljs-comment">//该位置存在瓜</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        temp = temp.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ifExist)&#123;<br>        temp.pre.next = newWatermelon;<br>        temp.next.pre = newWatermelon;<br>        newWatermelon.pre = temp.pre;<br>        newWatermelon.next = temp.next;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;该位置本来就没有瓜，不用换&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>对面的人凶神恶煞还拿着刀，可以拿走不熟的生瓜蛋子，防止被捅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeAway</span><span class="hljs-params">(<span class="hljs-type">int</span> location)</span>&#123;<br>    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-literal">null</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;今天的瓜已经卖完了&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">Watermelon</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ifExist</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<span class="hljs-comment">//标记一下，假如该位置没有瓜，本来就不用拿走</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span> (temp.next == <span class="hljs-literal">null</span>)<span class="hljs-comment">//没找到位置</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">if</span> (temp.location == location)&#123;<br>            ifExist = <span class="hljs-literal">true</span>;<span class="hljs-comment">//该位置存在瓜</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        temp = temp.next;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (ifExist)&#123;<br>        temp.pre.next = temp.next;<br>        temp.next.pre = temp.pre;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;该位置本来就没有瓜，不用拿走&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><p>查看瓜摊情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>)&#123;<br>        System.out.println(<span class="hljs-string">&quot;今天的瓜已经卖完了&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">Watermelon</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> head.next;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">break</span>;<br>        System.out.println(temp);<br>        temp = temp.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><h3 id="写个主类"><a class="markdownIt-Anchor" href="#写个主类"></a> 写个主类</h3><p>好，现在瓜摊的几个功能写完了，只需要随便写个主类，加几个功能就可以啦~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubleLinkedList</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;摆一个地摊&quot;</span>);<br>        <span class="hljs-type">Stall</span> <span class="hljs-variable">stall</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stall</span>();<br>        System.out.println(<span class="hljs-string">&quot;放几个西瓜，趁人不注意，塞俩生瓜蛋子&quot;</span>);<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;熟瓜&quot;</span>));<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;熟瓜&quot;</span>));<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;熟瓜&quot;</span>));<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;熟瓜&quot;</span>));<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&quot;熟瓜&quot;</span>));<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;生瓜蛋子&quot;</span>));<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">7</span>,<span class="hljs-string">&quot;生瓜蛋子&quot;</span>));<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">8</span>,<span class="hljs-string">&quot;熟瓜&quot;</span>));<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">9</span>,<span class="hljs-string">&quot;熟瓜&quot;</span>));<br>        stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(<span class="hljs-number">10</span>,<span class="hljs-string">&quot;熟瓜&quot;</span>));<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">function</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">stop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        System.out.println(<span class="hljs-string">&quot;0：收摊\n&quot;</span> +<br>                <span class="hljs-string">&quot;1：末尾摆一个瓜\n&quot;</span> +<br>                <span class="hljs-string">&quot;2：中间位置插入一个瓜\n&quot;</span> +<br>                <span class="hljs-string">&quot;3：来了个新手，换上一个生瓜蛋子\n&quot;</span> +<br>                <span class="hljs-string">&quot;4：来了个找茬儿的，拿走一个生瓜蛋子\n&quot;</span> +<br>                <span class="hljs-string">&quot;5：查看瓜摊情况&quot;</span>);<br>        <span class="hljs-keyword">while</span>(stop)&#123;<br>            <span class="hljs-keyword">switch</span>(function.nextInt())&#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                    stop = <span class="hljs-literal">false</span>;<br>                    System.out.println(<span class="hljs-string">&quot;收摊走人~&quot;</span>);<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                    System.out.println(<span class="hljs-string">&quot;输入瓜的位置和成熟程度&quot;</span>);<br>                    stall.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(scanner.nextInt(),scanner.next()));<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                    System.out.println(<span class="hljs-string">&quot;输入瓜的位置和成熟程度&quot;</span>);<br>                    stall.addByOrder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(scanner.nextInt(),scanner.next()));<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                    System.out.println(<span class="hljs-string">&quot;输入瓜的位置和成熟程度&quot;</span>);<br>                    stall.exchange(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Watermelon</span>(scanner.nextInt(),scanner.next()));<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                    System.out.println(<span class="hljs-string">&quot;输入瓜的位置和成熟程度&quot;</span>);<br>                    stall.takeAway(scanner.nextInt());<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>                    stall.show();<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr /><blockquote><p>读者看完可以自行编写实现功能或者在公众号获取完整源码，尝试做一天瓜摊老板吧~<br><br />微信公众号“一只达瓦里氏”后台回复0816获取完整源码</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>性别矛盾</title>
    <link href="/2023/06/21/%E6%80%A7%E5%88%AB%E7%9F%9B%E7%9B%BE/"/>
    <url>/2023/06/21/%E6%80%A7%E5%88%AB%E7%9F%9B%E7%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img.gejiba.com/images/65f8a7ddb18567c926af3c93c3da34a1.png" alt="" /><br /><img src="https://img.gejiba.com/images/4cd09c067cce6180701ad5d86484e669.png" alt="" /><br /><img src="https://img.gejiba.com/images/3f745f8f53696758da445d732e299888.png" alt="" /><br />综合思维导图如下, 可以尝试右键保存图片本地观看<br /><img src="https://img.gejiba.com/images/3c37c7b9a285747a1ad33bb8759f6159.png" alt="综合思维导图" /></p>]]></content>
    
    
    <categories>
      
      <category>左翼思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>马克思主义</tag>
      
      <tag>阶级矛盾</tag>
      
      <tag>性别矛盾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一个工人读史的困惑</title>
    <link href="/2023/06/21/%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BA%BA%E8%AF%BB%E5%8F%B2%E7%9A%84%E5%9B%B0%E6%83%91/"/>
    <url>/2023/06/21/%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BA%BA%E8%AF%BB%E5%8F%B2%E7%9A%84%E5%9B%B0%E6%83%91/</url>
    
    <content type="html"><![CDATA[<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">    <iframe src="//player.bilibili.com/player.html?aid=386440715&bvid=BV1ud4y1U7mM&cid=787143336&page=1"  scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"></iframe></div><hr /><p><strong>《一个工人读史的困惑》</strong><br />(贝托尔特·布莱希特。翻译版本较多，这里只选取一种)</p><blockquote><p>那七个城门的底比斯是谁建造的？<br><br />书本上列了一些国王的名字。<br><br />石头和砖块是国王搬的吗？<br><br />还有巴比伦，一再被摧毁<br><br />是谁又一再将她重建？<br><br />金光闪闪的利马的建筑工人，<br><br />他们住的房子在什么地方？<br><br />砌了一天的城墙，<br><br />天黑之后，<br><br />万里长城的泥水匠在哪里过夜？<br><br />雄伟的罗马到处都有凯旋门。<br><br />那是谁打造的？<br><br />那些罗马皇帝战胜的又是谁？<br><br />大名鼎鼎的拜占庭<br><br />它的居民都住在宫殿吗？<br><br />传说中的亚特兰提斯，<br><br />大海先淹没奴隶，<br><br />然后那些主子才漂浮在黑夜的汪洋中哀嚎。<br><br />年轻的亚历山大征服了印度。<br><br />就凭他一人吗？<br><br />西泽打败了高卢人，<br><br />他该不会连个煮饭的都没带吧？<br><br />无敌舰队沉没的时候，<br><br />西班牙的腓力哭了。<br><br />没有别的人哭吗？<br><br />腓特烈大帝在七年战争中获胜。<br><br />除了他还有谁获胜？<br><br />页页有胜利。<br><br />谁来准备庆功宴？<br><br />代代出伟人。<br><br />谁来买单？<br><br />一大堆史实。<br><br />一大堆疑问。<br></p></blockquote><hr /><blockquote><p>《防暑降温措施管理办法》安监总安健[2012]89号第八条<br><br />在高温天气期间，用人单位应当按照下列规定，根据生产特点和具体条件，采取合理安排工作时间、轮换作业、适当增加高温工作环境下劳动者的休息时间和减轻劳动强度、减少高温时段室外作业等措施：<br><br />（一）用人单位应当根据地市级以上气象主管部门所属气象台当日发布的预报气温，调整作业时间，但因人身财产安全和公众利益需要紧急处理的除外：<br><br />1、日最高气温达到40℃以上，应当停止当日室外露天作业；<br><br />2、日最高气温达到37℃以上、40℃以下时，用人单位全天安排劳动者室外露天作业时间累计不得超过6小时，连续作业时间不得超过国家规定，且在气温最高时段3小时内不得安排室外露天作业<br><br />3、日最高气温达到35℃以上、37℃以下时，用人单位应当采取换班轮休等方式，缩短劳动者连续作业时间，并且不得安排室外露天作业劳动者加班。<br><br />（二）在高温天气来临之前，用人单位应当对高温天气作业的劳动者进行健康检查，对患有心、肺、脑血管性疾病、肺结核、中枢神经系统疾病及其他身体状况不适合高温作业环境的劳动者，应当调整作业岗位。职业健康检查费用由用人单位承担。<br><br />（三）用人单位不得安排怀孕女职工和未成年工在35℃以上的高温天气期间从事室外露天作业及温度在33℃以上的工作场所作业。<br><br />（四）因高温天气停止工作、缩短工作时间的，用人单位不得扣除或降低劳动者工资。<br><br />用人单位安排劳动者在35℃以上高温天气从事室外露天作业以及不能采取有效措施将工作场所温度降低到33℃以下的，应当向劳动者发放高温津贴，并纳入工资总额。<br></p></blockquote><hr /><blockquote><p>农兵工这么辛苦，想必都在城市有一套房子吧</p></blockquote><blockquote><p>过去我认为湘潭县大，湖南省更大，中国自古就称为天下，当然大得了不得。但从这个地图上看来，中国只占世界的一小部分，湖南省更小，湘潭县在地图上没有看见，韶山当然更没有影子了。世界原来有这么大！<br />世界既大，人就一定特别多。这样多的人怎样过生活，难道不值得我们注意吗？从韶山的情形来看，那里的人大都过着痛苦的生活，不是挨饿，就是挨冻。有无钱治病看着病死的；还有家庭里、乡邻间，为着大大小小的纠纷，吵嘴、打架，闹得鸡犬不宁，甚至弄得投塘、吊颈的；至于没有书读，做一世睁眼瞎子的就更多了。在韶山冲里，我就没有看见几个生活过得快活的人。韶山冲的情形是这样，全湘潭县、全湖南省、全中国、全世界的情形，恐怕也差不多！<br />我真怀疑，人生在世间，难道都注定要过痛苦的生活吗？决不！为什么会有这种现象呢？<br />——1951年 毛泽东</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>左翼思想</category>
      
    </categories>
    
    
    <tags>
      
      <tag>马克思主义</tag>
      
      <tag>人民史观</tag>
      
      <tag>阶级矛盾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL忘密码了怎么办</title>
    <link href="/2023/06/21/MySQL%E5%BF%98%E5%AF%86%E7%A0%81%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/"/>
    <url>/2023/06/21/MySQL%E5%BF%98%E5%AF%86%E7%A0%81%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E/</url>
    
    <content type="html"><![CDATA[<p><a href="http://t.csdn.cn/mFZZj">教程原文</a></p><ol><li><p>管理员模式打开cmd，如果还开着mysql服务那先关掉<code>net stop mysql</code><br />用如下命令打开越权模式<br /><code>mysqld --console --skip-grant-tables --shared-memory</code><br />这样可以越权模式打开mysql，保留这个黑窗口<br /><img src="https://img.gejiba.com/images/3267fbb2193cabd2d0f97388665052c5.png" alt="" /></p></li><li><p>用管理员身份打开一个cmd<br /><code>mysql -u root -p</code><br />让输入密码时无需输入直接回车就可以进入root用户<br />（上一步没有关闭mysql服务这一步就会失败）</p></li><li><p>刷新权限，不然不允许改密码<br /><code>flush privileges;</code></p></li><li><p>改密码为123<br /><code>alter user 'root'@'localhost' identified by '123';</code></p></li><li><p>再刷新一下权限就可以了<br /><code>flush privileges;</code><br /><img src="https://img.gejiba.com/images/d30c87e2c9bb2d6ca0eb22fb855ad4df.png" alt="" /></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>KMP详解</title>
    <link href="/2023/06/12/KMP/"/>
    <url>/2023/06/12/KMP/</url>
    
    <content type="html"><![CDATA[<p><a href="https://img.gejiba.com/image/EegrG8"><img src="https://img.gejiba.com/images/40bc3cb7697a13d587b80e33feb3dcc9.png" alt="40bc3cb7697a13d587b80e33feb3dcc9.png" /></a></p><blockquote><p>KMP的本质是通过已经掌握的而信息来规避重复的运算</p></blockquote><blockquote><p>只需要一次主串的遍历就可以完成匹配，next数组的存在让j的回溯不需要循环，而是提前准备好表备查，这样没有循环的嵌套，复杂度仅为O(n)</p></blockquote><table><thead><tr><th style="text-align:center">pattern</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th></tr></thead><tbody><tr><td style="text-align:center">j</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr></tbody></table><p>可以看出来，next数组存的是如果该位置匹配失败那么该跳到哪里，j=4如果匹配失败了，那么此时前后缀长度为1，应该回溯到j=1。这样的话，我们构建next数组的时候只需要把当前位置产生的前后缀信息放到下一个位置便可以了，也就是说，最后一个位置的前后缀信息是不用比较的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(String target, String pattern)</span>&#123;<br>    <span class="hljs-keyword">return</span> indexOf(target, pattern, <span class="hljs-number">0</span>);<span class="hljs-comment">//下一个写的是从固定位置开始比较，不写位置的话默认从0位置开始比较</span><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">indexOf</span><span class="hljs-params">(String target, String pattern, <span class="hljs-type">int</span> begin)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> target.length(), m = pattern.length();<br>    <span class="hljs-keyword">if</span>(begin&lt;<span class="hljs-number">0</span>)<br>        begin = <span class="hljs-number">0</span>;<span class="hljs-comment">//begin容错</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span> || n&lt;m || begin&gt;=n)<span class="hljs-comment">//目标串长度为0，目标串小与模式串，开始比较的位置bigin就已经越界，均不符合要求</span><br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    next = getNext(pattern);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> begin,j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i&lt;n &amp;&amp; j&lt;m)&#123;<br>        <span class="hljs-comment">//循环条件：i比到n，j比到m</span><br>        <span class="hljs-keyword">if</span>(j==-<span class="hljs-number">1</span> || target.charAt(i)==pattern.charAt(j))&#123;<br>            <span class="hljs-comment">//比对成功可以让指针加1</span><br>            <span class="hljs-comment">//也可能j是被回溯，然后再来比较，并且有可能直接被回溯为-1，如果回溯为-1，说明没有可以利用的子串信息，直接比下一对就行，所以也需要两指针+1</span><br>            <span class="hljs-comment">//回溯到-1和0是不一样的，0还需要比较一下i和j=0两位置的字符，失败的那个位置没有可以用的子串信息，只能和第0号字符比较了，但是如果回溯到了-1，说明，第0号元素也不用比较了，这一次的匹配失败已经证明了和第0个肯定不相同，直接回溯到-1，就能在下一次循环中让两个指针+1，不用浪费一次比较</span><br>            i++;<br>            j++;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            j = next[j];<span class="hljs-comment">//匹配字符失败，j回溯</span><br>            <span class="hljs-keyword">if</span>(n-i+<span class="hljs-number">1</span>&lt;m-j+<span class="hljs-number">1</span>)<span class="hljs-comment">//如果目标串长度还没子串长，那就不用比了</span><br>                <span class="hljs-keyword">break</span>;<br>            <br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> j==m?i-m:-<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>构建next</p><blockquote><ol><li>k前缀长度一定是依次增加，不能跳</li><li>pattern[k] != pattern[j]的时候前缀需要缩短，怎么缩短？k回溯一次</li><li>课本的这个版本next数组情况稍有不同，j位置的next值存的是以j-1为尾的后缀的长度，所以前缀指针匹配失败的时候，直接找next[k]就能找到k-1位置字符上一次出现的位置，回溯略微方便一点</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] getNext(String pattern)&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, k = -<span class="hljs-number">1</span>;<span class="hljs-comment">//双指针，同时k也表示当前的前后缀长度</span><br>    <span class="hljs-type">int</span> next[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[pattern.length()];<br>    next[<span class="hljs-number">0</span>] = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(j&lt;pattern.length()-<span class="hljs-number">1</span>)&#123;<span class="hljs-comment">//构建的时候上一个位置的前后缀长度写在下一个位置的next上，所以只需要比较到倒数第二个，最后一个next也能写上</span><br>    <span class="hljs-keyword">if</span>(k==-<span class="hljs-number">1</span> || pattern.chatAt(j)==pattern.charAt(k))&#123;<span class="hljs-comment">//k==-1表示是第一个，先加一下，如果两个指针的位置匹配成功也可以加一下</span><br>        j++;<br>        k++;<span class="hljs-comment">//匹配成功那么前后缀长度加1</span><br>        next[j] = k;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//没有匹配成功，那么需要找上一个和k-1位置相同的字符，不对一下能不能和j位置匹配成功，那么上一个和k-1字符相同的在哪呢？在next[k]</span><br>        k = next[k];<br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>改进next数组<br />通过例子来看为什么需要改进</p><table><thead><tr><th style="text-align:center">target</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">b</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th></tr></thead><tbody><tr><td style="text-align:center">pattern</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center">a</td><td style="text-align:center">b</td><td style="text-align:center">c</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">next</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>那么从上述例子来看的话，由于target串中的b对比失败，需要将指针j回溯到j=2，但是很明显如果j=5没有匹配上的话，j=2也匹配不上，因为j=5和j=2两个位置的字符一样！</p><p>所以，next数组还能进行改进，使得时间复杂度进一步下降</p><table><thead><tr><th style="text-align:center">pattern</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th></tr></thead><tbody><tr><td style="text-align:center">前后缀长度k(第一版next)</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">改进后的next</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr></tbody></table><blockquote><p>这里的-1怎么理解？<br />回溯到-1和0是不一样的，0还需要比较一下i和j=0两位置的字符，失败的那个位置没有可以用的子串信息，只能和第0号字符比较了，但是如果回溯到了-1，说明，第0号元素也不用比较了，这一次的匹配失败已经证明了和第0个肯定不相同，直接回溯到-1，就能在下一次循环中让两个指针+1，不用浪费一次比较</p></blockquote><p>总结一下怎么个改进思想：回溯j的时候，我们回溯到的位置是可利用子串的后一个位置，但是如果这个位置和匹配失败的位置的字符一样的话，那其实一定匹配不上，可以利用旧next表回溯的位置的next值接着缩短前后缀，因为那个位置的next值是匹配不上的时候用的，如果我们提前知道匹配不上那其实也就可以提前用这个信息，一直循环缩短到和j位置不一样为止，这样和j位置不一样的话起码还有得比，不然回溯位置一样的话根本不用比</p><p>一句话，<strong>回溯一定要回溯到不一样的字符</strong>，要是回溯位置和原来一样，那一定匹配失败，还得回溯，不如我们在next数组里就把这一步工作做了，减少indexOf()函数里while的工作量</p><p><strong>改进就是避免跳转之后相同</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span>[] getNext(String pattern)&#123;<br>    <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>, k=-<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span>[] next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>(pattern.lenght());<br>    <span class="hljs-keyword">while</span>(j&lt;pattern.length-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(k==-<span class="hljs-number">1</span> || pattern.charAt(j)==pattern.chatAt(k))&#123;<br>            j++;<br>            k++;<br>            <span class="hljs-keyword">if</span>(pattern.chatAt(j==pattern.charAt(k)))<br>                next[j] = next[k];<span class="hljs-comment">//用k处的next值复制给j处(缩短前缀)</span><br>                <span class="hljs-comment">//这里有个问题，那要改进版的next需要连续缩短两次或者更多呢呢？</span><br>            <span class="hljs-keyword">else</span><br>                next[j] = k;<span class="hljs-comment">//一直到不相等的时候才能用指针赋值</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            k = next[k];<span class="hljs-comment">//前缀缩短</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> next;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果改进版的next需要连续缩短前缀两次或者更多呢呢？<br />如果需要连续缩短，那么中间那个位置的它当年也是想这么想的，所以它存的就是匹配失败时需要跳转的位置，见下方例子</p></blockquote><table><thead><tr><th style="text-align:center">pattern</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">d</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th><th style="text-align:center">a</th><th style="text-align:center">b</th><th style="text-align:center">c</th><th style="text-align:center">a</th><th style="text-align:center">a</th></tr></thead><tbody><tr><td style="text-align:center">索引</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">6</td><td style="text-align:center">7</td><td style="text-align:center">8</td><td style="text-align:center">9</td><td style="text-align:center">10</td><td style="text-align:center">11</td><td style="text-align:center">12</td><td style="text-align:center">13</td></tr><tr><td style="text-align:center">第一代next</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td><td style="text-align:center">5</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">改进版next</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">5</td><td style="text-align:center">-1</td><td style="text-align:center">4</td></tr></tbody></table><blockquote><p>这个例子中，计算改进版next时，9号元素a如果匹配失败需要返回3，但是3号元素也是a，所以此时需要k = next[k]，next[k]是-1而不是0，所以连续缩短前缀并不需要循环，一次就能到位</p></blockquote><p>可以看到改进版的next数组各个数字并不连续</p>]]></content>
    
    
    <categories>
      
      <category>技术笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法</tag>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/06/12/hello-world/"/>
    <url>/2023/06/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
